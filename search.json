[{"categories":["Algorithm"],"content":"본인 대학 대회인 2022 SKKU 프로그래밍 대회 in 소프트의 밤에 문제를 출제했다. Problem solving을 하면서 한 번쯤은 문제를 출제해보고 싶다는 생각을 했었는데, 이번에 기회가 생겨서 하게 되었다. 본인은 C번(수렵의 시간이다!)과 I번(전투 시뮬레이션)을 출제했다.\nC. 수렵의 시간이다! 문제를 보고 아는 사람도 있을 텐데, 문제에 나온 M게임은 몬스터 헌터를 말한다. 쉬운 브론즈~실버급 문제들을 만들어야 했는데, 당시 몬스터 헌터 라이즈: 선브레이크를 즐겁게 한 경험이 있어서 해당 게임의 스킬과 괴의 연성 시스템을 가져와서 만들었다.\n처음에는 원본 게임처럼 방어구 종류도 5가지고, 스킬 종류도 $N$으로 유동적으로 바뀌었다. 그리고 그냥 brute-force로 만들기엔 특색이 없어서, 스킬 종류를 $1\\,000$까지 늘려 현재 상태에서 강화를 할 때 최대 이득을 set 을 이용해 $O(logN)$만에 구하도록 정했다. 하지만 이렇게 하니까 입력 형식이 난해하고 너무 어렵다는 의견이 나와서 방어구 종류를 3가지로 줄이고, 스킬 종류도 5개로 고정해서 그냥 brute-force 문제로 바꿨다.\n문제 내용이 길고 구현이 조금 힘들지만, 그냥 brute-force로 모든 경우를 보면 되기 때문에 운영진 예상 난이도 실버2~1로 나왔고, C에 배치했다. 하지만 실제 대회에서는 E번보다 적게 풀린(C:9명 / E: 17명) 결과가 나왔다… 지문이 길고 구현할 것이 많다 보니 상대적으로 지문이 짧은 D/E번을 먼저 푼 것 같다. 그리고 강화 부분 때문에 구현이 많이 복잡해 지는데, 강화를 빼거나 최소한 예제 1번에 대한 그림이라도 넣었어야 하는 생각이 든다. 다음에는 최대한 이해되기 쉬운 문제를 만들어야겠다.\nI. 전투 시뮬레이션 이 문제는 처음에는 Mo’s를 풀이로 만들던 문제였다. Meta Hacker Cup 2022 Round 2의 A2를 잘못된 풀이로 접근한 것에서 아이디어가 시작되었다. 그때 Mo’s 영역을 2개로 나누어서 관리하는 풀이를 생각했는데, 이 아이디어가 괜찮은 것 같아서 영역을 3개로 나누는 것으로 확장했다. Mo’s는 영역을 확장/축소시키는 연산이 빨라야 의미가 있다. 그래서 처음에는 영역을 연속된 A, B, C 3개로 나누고, A-B, A-C, B-C 3가지 경우에서 왼쪽 영역에 있는 수보다 오른쪽 영역에 있는 수가 더 큰 pair의 개수를 출력하는 것을 쿼리로 하는 문제였다. 하지만 이 문제는 마음에 들지 않았는데,\n너무 Mo’s를 쓰라고 만든 문제 같음 구현이 매우 복잡함 (구현해보니까 300줄 넘게 나온 것으로 기억한다) 확장/축소때마다 $O(logN)$인데, 여기에 상수도 커서 $N$과 $Q$의 제한을 잡기가 힘들다 그래서 열심히 고민하다가 이 문제를 떠올리게 되었다. 추가적인 지식(Prefix Sum, 식 정리)이 필요하고, 구현도 조금 쉬워져서 이 문제로 결정했다.\n그런데 출제자 회의에서 이 문제를 설명하니까, 그냥 Merge Sort Tree 쓰면 되는 거 아님? 이라는 의견이 나왔고, 생각해보니까 정말로 그래서 그냥 Merge Sort Tree를 쓰는 걸로 결정했다. 덕분에 시간복잡도가 줄어서 $N$과 $Q$ 제한을 쉽게 잡을 수 있었다.\n이러면 의도한 풀이의 시간복잡도는 $O(Qlog^2N)$인데, 검수진 중 한 분이 Offline Query + Segment Tree로 $O(QlogN)$에 풀어서 해당 풀이도 추가했다. 대회 중 한 분이 이 풀이로 풀었다.\n대회 때 뒤에 4문제 중 유일하게 풀린 문제가 되었는데, 구현이 힘들거나 기발한 아이디어가 요구되는 문제는 아니라서 그런 것 같다.\n나머지 문제 A. 안녕 클레오파트라 세상에서 제일가는 포테이토칩 대학교 대회라 쉬운 문제들도 필요해서 만들어진 문제다. 쉬운 문제라 딱히 이슈는 없었다.\nB. 장인은 도구를 탓하지 않는다 순서는 상관없는 약간 낚시성? 문제다. 이것도 딱히 이슈는 없었던 것 같다.\nD. 양과 늑대 출제자 분이 인터렉티브 문제를 내보고 싶어서 낸 문제다. 하마타면 출제를 못 할 뻔한 문제다. 인터렉터를 잘못 짜서 undefined behavior인 동작이 있었는데, 이게 polygon에서와 백준에서 다르게 동작해서 ! 0 만 출력해도 맞는 경우가 생겼다! 게다가 인터렉티브 문제는 백준님께 직접 전달해서 수정해야 해서 딜레이가 꽤 걸렸다. 다행히 대회 당일 날 수정되었고 잘 작동해서 출제할 수 있었다.\n대학교 대회다 보니, 이런 인터렉티브 문제에 익숙하지 않은 사람들이 많을 것 같아서 안내 메일에 인터렉티브 문제가 나오니 한 번 예제문제들 풀어보세요 라고 추가를 했다. 그 덕분인지, 생각보다 많은 사람들이 문제를 풀어주었다. 그래도 틀리는 사람들이 종종 있었는데, 가장 안타까운 경우는 풀이는 맞는데 질문할 때 개행문자(\\n)을 안 넣어서 시간초과가 나는 사람들이 있었다. 만약 인터렉티브 문제를 대회 때 낼 계획이라면, 개행문자를 꼭 넣으라고 명시하는 것이 좋을 것 같다.\nE. 수열의 합 원래 이 문제는 Small 버전과 Large 버전 2가지가 있었다. Small 버전은 $N$이 지금보다 작은 $100\\,000$이라서 그냥 약수를 다 구하는 $O(N\\sqrt{N})$로 풀 수 있고, Large 버전은 $10^{14}$라서 조화 수열을 이용해 풀어야 한다. 하지만 문제 수가 너무 많아져서 Large 버전은 제외되었고, Small 버전에 에라토스테네스의 체는 통과 못 하게 $O(N)$만 통과하도록 문제를 수정했다.\n그런데 검수진 분들이 낸 체를 이용한 풀이가 빠르게 돌아가 맞는 경우들이 생겼다. 그래서 그냥 빠르게 돌아가는 체는 맞도록 결정을 했다. 대회 때 이렇게 푼 사람들도 꽤 있었다. 다만 PyPy를 쓰면 그냥 체를 써도 맞는 경우가 생기는 것을 대회 때 알았다.\nF. 수확의 계절이다! 원래는 크기 제한이 있어서 2차원 배열에 풀 수 있었는데, 골드 중간 문제가 없어서 난이도를 올린 문제이다. 파라매트릭 서치를 해도 지나가는 경로들은 모두 같기 때문에 매번 좌표를 map\u003c \u003e에 넣을 필요 없이 미리 전처리를 하는 것이 핵심이고, 이렇게 안 하면 시간초과가 나도록 설계했다. 그래서 대회 때 시간초과가 나는 사람들이 많았다.\n문제는 이 문제도 PyPy를 쓰면 좀 오래 걸리지만 전처리를 안 해도 맞는다는 점이다…(이것도 대회 때 알았다) PyPy 너무 사기에요\nG. 게이트웨이 정하기 처음에는 트리의 간선에 가중치가 있고 데이터를 보낼 때 가중치만큼 나눠져서 보내지고… 이런 문제였던 것 같은데 이러니까 계속 1 이하 실수로 곱해져서 소수점 오차를 막을 수가 없었다. 그래서 출제자 분이 XOR로 바꿔보겠다고 하고 조금 수정해서 나온 문제다. XOR 문제를 많이 풀어봤다면 어렵지 않게 풀 수 있는 문제인 듯하다.\nH. 현상금 헌터 이 문제는 좌표 범위가 제한되어 있었는데, 생각해보니까 현재 시간만 알고 있으면 다음 도둑을 잡는 좌표는 자동으로 정해지기 때문에 범위 제한을 없앴다.\n그리고 처음에는 정수 좌표에서만 잡을 수 있었다. 그런데 그러면 지문도 조금 길어지고 개인적으로 별로 마음에 안 들었다. 조금 생각을 해 보니까 실수 좌표여도 0.5단위로만 잡는다는 것을 알 수 있었고, 깔끔하게 풀 수 있어서 수정되었다.\n결국 시간만 알면 특정 도둑을 최단시간으로 잡는 좌표가 정해지고, 이게 최선이라는 것을 알기만 하면 어렵지 않지만, 이를 알기가 쉽지 않아서인지 대회 때는 제출이 없었다.\n+ 저게 좀 많이 어려운지 Open Contest때도 가장 늦게 풀렸다…\nJ. 달나라에 사는 토끼와 우주에서 떨어지는 떡 사이클을 중심으로 생각하면 어렵지 않으나, 구현이 좀 많이 빡세다. 본인도 DFS를 3번 돌려서 겨우 풀었다. 실제 대회에서도 한 분이 막판에 시도하다가 결국 안 풀린 문제가 되었다.\nK. 커모드 곰의 연어 사냥 조건이 결국 bridge들의 컴포넌트인 것을 알면 어렵지 않게 풀 수 있는 문제다. 그래서 고인물들은 쉽게 풀 수 있을 것으로 생각했으나, 막상 앞에 문제들에서 막혀서 그런지 제출도 없었다.\n처음 출제해보기도 하고, 막학기라 다른 사람들에 비해 시간이 많아서 이 대회에 많은 시간을 썼다. polygon도 처음 써봤는데, 되게 CI/CD느낌이 나서 흥미로웠다. 그리고 스코어보드를 보면서 다양한 방법으로 푸는 것을 보는 것이 생각보다 재미있었다. 이제 졸업하면 Problem Solving을 잘 하진 못하겠지만, 나중에 기회가 된다면 다른 문제들도 출제해보고 싶다.\n참가해주신 모든 분들과 출제자/검수진 분들, 플랫폼을 제공해주신 Starlink분들에게 모두 감사의 말씀 드립니다.\n","description":"","tags":[],"title":"2022 SKKU 프로그래밍 대회 in 소프트의 밤 출제 후기","uri":"/posts/2022/2022-skku-programming-contest-review/"},{"categories":["Algorithm"],"content":"문제들 중에 k번째로 작은/큰 값을 구하는 경우가 있다. 이때 Fracturing Search를 쓰면 효율적으로 구할 수 있다.\nFracturing Search 문제에서 만들 수 있는 여러 상태들이 있고, 각 상태들은 값을 가지고 있다. 이때 다음 조건을 만족하는 상태 트리를 만들 수 있다.\n트리에서 노드에 대응되는 모든 상태들은 서로 겹치지 않는다. 자식 노드는 부모 노드보다 값이 크거나 같다. 이때 k번째 값은 priority queue를 이용하면 다음과 같이 빠르게 구할 수 있다.\n처음에 가장 작은 값 노드(상태)를 priority queue에 넣는다. priority queue에서 노드를 꺼낸다. 해당 노드의 자식 노드들을 priority queue에 넣는다. k번째 값을 찾을때까지 2-4를 반복한다. 이러면 가장 작은 값부터 차례대로 구할 수 있다. 해당 노드의 자식 노드들을 넣으면 남은 노드들은 현재 priority queue에 있는 노드들보다 무조건 크거나 같기 때문이다.\n결국 위의 두 조건을 만족하는 상태 트리를 잘 설계하는 것이 이 알고리즘의 핵심이다.\nK-th Smallest Spanning Tree 이름 그대로 k번째 MST를 구하면 된다.\n일단 MST를 구하자. 그러면 n-1개의 간선들이 선택되었을 것이고, 이것은 첫 번째 상태가 된다. 이제 이 상태에서 다음 MST를 어떻게 구해야 할까? 선택된 간선들 중 하나를 제외하고 MST를 구하는 게 다음 MST라는 것을 생각할 수 있다.\n트리에서 간선을 추가하면 무조건 cycle이 생기게 되는데, cycle 안에서 현재 MST의 간선을 제거해야만 현재 MST와는 다른 MST가 나오기 때문이다.\n위의 그림처럼 파란색 영역이 선택된 간선일 때, 다음 상태는 선택된 간선들 중 하나를 제외하는 것이고, 이것을 priority queue에 넣으면 된다. 여기서 주의할 점은, 간선을 제외할 때 앞에 있는 간선을 무조건 MST에 포함되도록 강제해야 한다는 점이다. 이래야 상태 트리에서 노드들이 중복되지 않기 때문이다. 이러한 기법은 Fracturing Search를 할 때 자주 이용된다. 이렇게 강제/제외된 간선을 반영한 MST의 값을 구하고 priority queue에 넣으면 된다.\n각 상태마다 MST를 구해야 하고, 자식의 개수는 선택된 간선의 개수\\( (N) \\)이므로, 시간복잡도는 \\( O(KN(logKN + M\\alpha(N))) \\)이다. (상태 개수 * (priority queue 연산 + MST 연산))\nBOI 2019 - Olympiads (BOJ 17188) BOJ 링크\n위의 문제와 거의 똑같이 접근하면 된다. 가장 큰 점수를 가지는 참가자 그룹은 각 event마다 아직 안 고른 참가자들 중 가장 큰 점수를 가지는 참가자를 고르면 된다. 이렇게 고른 상태에서, 선택한 참가자를 하나씩 제외한 상태를 넣으면 된다. 시간복잡도는 \\( O(CK(logCK + NK)) \\)이다.\n소스 코드\nUSACO 2016 December - Robotic Cow Herd (BOJ 14166) BOJ 링크\n가장 작은 상태는 각 location에서 가장 작은 model을 선택하면 된다. 다음 상태는 각 location별로 다음 model을 선택한다. 이때 역시 중복을 막기 위해 현재 i번째 location의 model을 선택했다면 다음 선택은 i번째 ~ n번째 location을 선택한다. 하지만 이러면 시간복잡도는 \\( O(KNlog(KN)) \\)라서 \\( KN \\)때문에 시간 안에 나올수가 없다.\nmodel의 개수가 각각 3, 3, 3개 있는 데이터의 상태 트리이다. 결국 문제는 자식 노드의 개수가 최대 n개가 된다는 점이다. 이때 초록색 영역을 살펴보면, 자식들이 나누어지는 경우는\n현재 자기 location의 다음 model을 선택 자기 location을 고정하고 다음 location ~ 마지막 location의 다음 model (0번째-\u003e1번째) 을 선택 (초록색 영역) 이다. 여기서 0번째-\u003e1번째 증가 비용을 기준으로 location을 정렬하면, 2번 경우에서 i+1번째 location만 하고 나머지 상태는 나중으로 미뤄도 된다. 왜냐하면 정렬을 하면서 i+1번째 location을 선택한 상태가 그 이후 location을 선택한 상태 보다 비용이 작거나 같기 때문이다.\n빨간색이 나중으로 미루는 경우이다. 이러면 자식으로 나누어지는 경우는\n현재 자기 location의 다음 model 선택 자기 location을 고정하고 다음 location의 다음 model (0번째-\u003e1번째) 을 선택 만약 자기 location의 model이 1번째라면 0번째로 바꾸고 다음 location의 다음 model (0번째-\u003e1번째) 을 선택 (빨간색) 자식의 개수는 최대 3개가 되고, 시간복잡도는 \\( O(NlogN + KlogK) \\)가 되어서 시간 내에 충분히 나온다.\n소스 코드\nCCO 2020 - Shopping Plans (BOJ 19616) BOJ 링크\n위의 문제에 여러 개를 선택할 수 있고, 상/하한까지 있는 상위호환 문제다. 일단 문제를 작은 것 부터 차례대로 풀어보자.\n타입 1개에 상/하한 X 상/하한이 없다면 처음 상태는 당연히 아무 것도 안 고른 상태이다. 그다음 MST와는 반대로 무조건 한 개의 값을 고르는 방식으로 하면 된다. 물론 이전 값들은 고르지 않도록 고정해야 한다. 이러면 시간복잡도는 \\( O(NKlogNK) \\)고, 위에서 사용한 최적화를 적용하면 \\( O(NlogN + KlogK) \\)가 된다.\n타입 1개에 상/하한 O 상한은 상태에 고른 개수를 저장하고 상한보다 크면 컷하는 방식으로 하면 된다. 문제는 하한인데, 하한이 있을 때 경우를 생각해보자. 하한이 3일 때, 가장 작은 상태는 (0, 1, 2)다. 그다음 상태는 (0, 1, 3)이고, 그다음 상태는 (0, 1, 4), (0, 2, 3)… 이렇게 이어진다. 이것은 base로 (0, 1, 2)인 상태에서 뒤에서부터 대체하는 방식을 사용하면 된다. 시작을 3부터 시작하고, 만약 앞에 넣을 수 있으면 앞에 넣는 상태를 추가하면 된다.\n앞에 넣는다는 의미는 넣는 값이 x일 때 x-1을 x로 대체하는 것이다. 예를 들어 base가 (0, 1, 2)이고 현재 대체 상태가 (3)이라고 하면, 다음 대체 상태로 (2, 3)이 될 수 있다. 이것은 적용하면 (0, 2, 3)이 되고, 이는 1이 2로 대체된 것이다.\n파란색이 앞에 넣는 상태이다. 잘 보면 현재 크기에 따라 앞에 넣는 값이 같은 것을 볼 수 있다. 구현할 때 주의할 점은 현재 상태가 앞에 넣은 상태라면 빨간색으로 넘어가지 않아야 한다.\n타입 M개 이제 각 타입별로 k번째로 작은 값을 구할 수 있다. 이러면 위의 문제와 동일해지므로, 같은 방법으로 풀면 된다. 다만 각 타입별로 미리 c번째까지 구할 수 없기 때문에, 필요할 때마다 동적으로 구해야 한다. 로직상 타입별로 k번째는 순서대로 접근(0번째 -\u003e 1번째 -\u003e 2번째 -\u003e …)하게 된다.\n총 시간복잡도는 \\( O(NlogN + KlogK) \\)이다.\n소스 코드\n참고 자료 https://usaco.guide/adv/fracturing-search\nhttps://koosaga.com/275\n","description":"","tags":[],"title":"Fracturing Search","uri":"/posts/2022/fracturing-search/"},{"categories":["Programming","Etc"],"content":"최근에 아이패드를 샀다. 여러가지 이유가 있지만, 그 중 하나는 밖에서도 PS문제들을 편하게 풀기 위해서다. 기존에는 카페나 기차같이 밖에서 코딩할 일이 있으면 노트북을 들고 갔는데, 지금 쓰는 노트북이 게이밍 노트북이라 어댑터까지 포함하면 3kg가 넘어서 가지고 다니기 힘들었다. 그래서 가볍게 들고다니면서 코딩할 수 있는 패드를 사기로 결심했다.\n현재 노트북이 윈도우 환경이기 때문에, 가장 쉬운 방법은 Microsoft Surface Pro를 사는 것이다. 같은 윈도우 환경이라 그대로 똑같이 세팅하면 되기 때문이다. 하지만 Surface Pro 8은 아직 한국에 출시가 안 되었고, 그렇다고 이전 모델을 사기에는 8에서 너무 많이 바뀌어서 애매했다. 그리고 e-book, 동영상, 필기 등 다방면으로 활용하기에는 서피스는 조금 부족하다고 생각했다. 아이패드를 한 번 써보고 싶기도 했고…\n아무튼 그래서 아이패드로 결정하고 구입했는데, 문제는 아이패드에는 코딩할 수 있는 앱이 거의 없다는 점이다. Code App이라는 앱이 그나마 가장 나아보이는데, 유료고 확장성이 떨어진다고 생각해서 제외했다. 결국 서버를 올리고 원격으로 코딩하는 방안으로 결정했다. 여러 방법이 있지만, 그 중에서 code-server라는 것을 이용했다.\ncode-server code-server는 쉽게 말해서 Visual Studio Code를 서버에 올리고 이것을 웹에서 사용하는 프로그램이다. 이 프로그램은 원래 Coder라는 플랫폼에서 VSCode만 오픈소스로 따로 공개한 것이다. 서버에 모든 에디터 설정들이 있어서 언제 어디서나 같은 환경에서 개발할 수 있고, 부하가 심한 곳에 리소스를 임시로 더 할당할 수도 있다. 어차피 PS하는데 큰 리소스도 필요 없고, 기기가 바뀔때 마다 다시 설정할 필요도 없어져서 이것을 이용했다.\n설치 github repo에 가면 설치방법이 나와있다. 가장 간단한 방법은\n1 curl -fsSL https://code-server.dev/install.sh | sh 하면 자동으로 설치가 된다.\n설정과 실행 설치를 완료하면 ~/.local/share/code-server에 code-server 관련 파일이, ~/.config/code-server/config.yaml에 설정 파일이 있다. 설정 파일을 열어보면\n1 2 3 4 bind-addr: 127.0.0.1:8080 auth: password password: $PASSWORD$ cert: false 이렇게 있을 것이다. 여기서 접속할 주소/포트와 비밀번호를 설정 가능하다.\nnginx로 안전하게 연결하기 설정을 저장하고 code-server나 sudo systemctl start code-server@user_name를 입력하면 실행이 가능하나, 이렇게 바로 서버를 여는 것은 위험하다. 특히나 code-server는 접속하면 바로 터미널에 접근 가능하기 때문에 더 위험하다. 따라서 ssh나 https 같은 안전한 프로토콜을 거쳐서 열어야 한다. 자세한 내용은 code-server usage에서 확인 가능하다. 여기서는 nginx를 이용한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 server { listen 80; server_name your.domain.name; return 301 https://your.domain.name$request_uri; } server { listen 443 ssl http2; server_name your.domain.name; autoindex off; ssl_certificate /etc/letsencrypt/live/your.domain.name/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/your.domain.name/privkey.pem; location / { proxy_pass http://127.0.0.1:8080; proxy_set_header Host $host; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection upgrade; proxy_set_header Accept-Encoding gzip; } } nginx설정은 간단히 말하면 127.0.0.1:8080으로 reverse-proxy를 연결하는 것이다. 여기에 추가로 4개의 header를 넘겨주면 된다.\n접속해보면 로그인 화면이 뜨는데, 아까 설정한 비밀번호를 넣어서 접속하면 된다.\n비밀번호를 입력하면 웹 페이지에 VSCode 화면이 나오게 된다.\nProblem Solving을 위한 셋팅 이제 기존에 쓰던 환경대로 셋팅을 하면 된다. 다만 확장 프로그램을 설치하려고 검색을 해보면 확장 프로그램 수가 많이 적은 것을 알 수 있다. 이것은 code-server가 Visual Studio MarketPlace를 쓰는 것이 아니라 Open VSX를 쓰기 때문이다.\nVSCode는 소스 코드는 MIT Licence지만, Microsoft에서 받을 수 있는 VSCode 설치 파일은 MS 자체 라이센스다. 그리고 Visual Studio MarketPlace는 이렇게 MS에서 직접 빌드한 VSCode만 사용할 수 있도록 약관에 명시되어 있다. 그래서 VSCode로부터 파생된 다른 소프트웨어들은 다른 마켓 플레이스를 이용할 수 밖에 없다.\n참고 링크\nWhy can’t code-server use Microsoft’s extension marketplace? Differences between the repository and Visual Studio Code ccls 자동완성, 네비게이션, 구문 하이라이팅 등 에디터를 좀 더 편하게 사용하기 위해서는 language server가 필요하다. C++ language server로는 ccls를 이용했다. ccls는 Open VSX에 있기 때문에 바로 설치하면 된다. 다만 확장 프로그램은 ccls하고 VSCode하고 연결하는 프로그램이라 ccls는 따로 설치해야 한다. 빌드와 설치 방법은 ccls repo를 참조.\nPS를 하면서 매크로를 따로 선언하는 경우가 있는데 (Debug용, freopen…), 이때 ccls에도 반영하게 하려면 설정에서\n1 \"ccls.clang.extraArgs\": [\"-DDEBUG\", \"-DCUBE_PS\"] 를 추가하면 된다.\nCode Snippet PS를 하면서 미리 작성해둔 코드를 사용하는 경우가 많은데, VSCode 자체 기능인 Snippet기능을 이용하면 편리하다.\nFile -\u003e Preferences -\u003e User Snippets를 누르면 새로운 snippet을 생성 가능하다.\n1 2 3 4 5 6 7 8 9 10 \"Fast Fourier Transform\" : { \"scope\": \"cpp\", \"prefix\": \"psfft\", \"body\" : [ \"struct FFT\", \"{\", \" ...\", \"};\" ] }, 이런 식으로 snippet을 추가하면 된다. 특이한 점은 body부분이 각 줄마다 문자열로 넣어야 한다는 점이다. 이게 귀찮아서 본인은 각 줄마다 ““를 넣는 python 프로그램을 만들어서 변환해 넣었다.\nprefix로 지정한 문자를 입력하면 잘 나오는 것을 볼 수 있다.\n실행/디버깅 가장 간단한 방법은 vscode-cpptools를 이용하는 것 이지만, runtime licencse가 오픈 소스가 아니라서 VSX Open에 있지 않다. 아마 Windows에서 쓰는 빌드 툴이 오픈 소스가 아니라서 그런 것 같다. 그래서 수동으로 .visx를 받아서 설치했다.\ncode-server가 Linux에서 돌아가기 때문에 빌드나 디버그를 gcc/gdb를 사용해서 가능한 것 같다. 아마 Windows에서는 이 방식이 불가능 할 것이다.\nChrome에서 돌아가는 모습이다. 아직 아이패드가 안 와서 아이패드에서는 확인을 못 했으나, 지인의 갤럭시 탭에서 돌아가는 것을 확인해서 아마 아이패드에서도 잘 돌아갈 것이다.\n( + 2022-01-24 추가)\n아이패드가 와서 아이패드에서 돌려보았다.\n위 사진처럼 옆에다가 노트나 문제를 띄우고 사용하고 있다. 잘 작동하는데 몇 가지 불편한 점들이 있었다.\n왜 Safari에서는 설치한 글꼴이 반영이 안 되는지 모르겠다. 그래서 기본 글꼴 중 괜찮은 글꼴을 찾아서 바꿨다. 단축키가 macOS 기반으로 바뀌는데, 이게 Windows랑은 미묘하게 달라서 적응이 잘 안된다. 위에 주소창을 숨기는 전체화면 모드는 없는건가? 찾아봤는데 딱히 찾을 수 없었다. 공유 버튼을 누르고 홈 화면에 추가를 하면 전체화면으로 열린다. 마우스가 없다보니 터치를 해야하는데 이게 생각보다 불편하다. 특히 창을 드래그해서 이동시키는 방법을 모르겠다. 그렇다고 트랙패드가 달린 매직키보드를 사기에는 너무 비싸다. 그래도 사용하는데 큰 지장은 없고, 전에 쓰던 게이밍 노트북보다 훨씬 가볍고 배터리도 오래가서 상당히 만족한다.\n","description":"","tags":[],"title":"code-server로 웹 브라우저에서 Problem Solving 하기","uri":"/posts/2022/problem-solving-in-web-browser-using-code-server/"},{"categories":["Algorithm"],"content":"백준에 하이퍼~ 라는 이름의 특이한 문제들이 있다. 모두 구데기컵 대회에 나온 문제들인데, 특징은 데이터가 11차원 이라서 11차원 배열을 써야 한다는 점이다. 듣기만 해도 끔찍해 보이는데, 천천히 생각을 하면 생각보단 쉽게 풀 수 있다.\n데이터 입력과 처리 3차원 데이터 입력받는것도 힘든데, 11차원의 데이터를 받아야 하니 벌써부터 막막하다. 11중 for문과 11개의 []로 처리는 가능하나, 좀 더 깔끔하게 풀기 위해서 재귀 함수와 template을 이용했다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 using hv = vector\u003cvector\u003cvector\u003cvector\u003cvector\u003cvector\u003cvector\u003cvector\u003cvector\u003cvector\u003cvector\u003cll\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e; hv arr; template \u003ctypename T\u003e void init(T\u0026 d, int dim) { d.resize(dimsz[dim]); for(int i = 0; i \u003c dimsz[dim]; ++i) { init(d[i], dim + 1); } } template \u003c\u003e void init(ll\u0026 d, int dim) { cin \u003e\u003e d; } init(arr, 0); 중첩 for문을 하나씩 함수에 넣어뒀다고 생각하면 된다. 맨 처음에 init 함수를 호출하면 T가 vector가 11개인 init이 호출된다. 이제 안에서 d[i]인 값으로 init 함수를 호출하면 맨 바깥에 있는 vector가 벗겨진 10개의 vector 타입으로 호출된다. 이것이 계속 반복되면 vector들이 다 사라지고 안에 있는 ll(long long) 타입만 남게 된다. 그러면 Explicit template specialization에 의해 아래에 있는 함수가 호출되고, 이때 입력을 받거나 연산을 처리하면 된다.\n위 코드는 배열을 초기화하고 입력을 받는 코드이고, 다른 연산은 밑에서 보거나 소스코드를 참조하자.\nBOJ 17114 - 하이퍼 토마토 BOJ 링크\n11차원 배열에 안 익은 토마토와 익은 토마토가 있는데, 익은 토마토는 주변의 안 익은 토마토를 1일 후 익은 토마토로 바꾼다. 이떄 모든 토마토가 익은 토마토가 되는 시간을 출력하면 된다.\n이런 4차원 이상의 배열은 머리로 떠올릴 수 없기 때문에, 떠올릴 수 있는 2/3차원으로 줄여서 생각해보자. 문제를 2차원으로 낮춰서 생각해보면 처음에 익은 토마토들을 queue에 넣고, queue에서 뽑으면서 인접한 안 익은 토마토를을 익게 하고 queue에 넣는, 전형적인 BFS로 풀 수 있다.\n이것을 똑같이 11차원에서 하면 된다. 다만 2차원에서는 인접한 구간이 상하좌우 4개라면, 11차원에서는 11개의 축 * 2 = 22개라는 점이다. 배열의 index를 vector로 저장하고, 인접한 곳에 접근할 때는 for를 돌려서 i번째 index를 +1, -1 하면 된다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 template \u003ctypename T\u003e bool ck(T\u0026 d, int dim, vector\u003cint\u003e\u0026 idx) { return ck(d[idx[dim]], dim + 1, idx); } template \u003c\u003e bool ck(ll\u0026 d, int dim, vector\u003cint\u003e\u0026 idx) { if(d == 0) { d = 1; return true; } return false; } ck(arr, 0, nxt); 배열 접근은 index를 담은 vector를 가지고 매 차원마다 해당하는 index에 접근하면 된다.\n참고로 이 문제는 밑에 두 문제와는 입력 방법이 조금 다른데, 이 문제는 첫 번째 축부터 입력은 받고 밑에 두 문제는 마지막 축부터 입력을 받는다. 본인은 뒤에서부터 문제를 풀어서 그냥 축들을 전부 뒤집고 입력을 받았다. (어차피 배열을 출력할 필요가 없으니까)\n소스 코드\nBOJ 18830 - 하이퍼 수열과 하이퍼 쿼리 BOJ 링크\n수열인데 배열이라 생각해도 된다. 문제가 조금 난해한데, 자세히 보면 그냥 쿼리마다 부분배열의 합을 구하는 문제이다.\n역시 2차원으로 낮춰서 생각해보자.\n2차원에서 부분배열의 합을 구하는 방법은 prefix sum 이용해 (0, 0) ~ (x2, y2) 구간에서 ┌자 영역을 빼면 된다는 것이 잘 알려져 있다. 이것을 각 축마다 A영역, B영역으로 나눠서 본다면 ┌자 영역이 \\( A + B - A \\cap B \\) 인 포함-배제의 꼴이라는 것을 관찰할 수 있다. 3차원에서도 생각해보면 포함-배제의 꼴로 성립한다. 그러므로 이를 11차원으로 확장해도 똑같다고 생각할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 template \u003ctypename T\u003e ll bt(int dim, T\u0026 d, vector\u003cint\u003e\u0026 a1, vector\u003cint\u003e\u0026 a2, int cnt) { ll res = 0; res += bt(dim + 1, d[a2[dim]], a1, a2, cnt); if(a1[dim] \u003e 0) { res += bt(dim + 1, d[a1[dim] - 1], a1, a2, cnt + 1); } return res; } template \u003c\u003e ll bt(int dim, ll\u0026 d, vector\u003cint\u003e\u0026 a1, vector\u003cint\u003e\u0026 a2, int cnt) { if(cnt \u0026 1) return -d; else return d; } ll query(vector\u003cint\u003e\u0026 a1, vector\u003cint\u003e\u0026 a2) { return bt(0, sum, a1, a2, 0); } 각 축을 돌면서 해당 축을 포함 안 시키는 경우는 0 ~ a2[dim], 포함 시키는 경우는 0 ~ a1[dim]-1 영역이 된다. 포함되는 개수가 홀수면 +, 짝수면 -인데, 어차피 구한 ┌영역의 값을 전체 영역에서 빼는 것이므로 부호를 반대로 뒤집었다.\n소스 코드\nBOJ 21298 - 하이퍼 배열 돌리기 BOJ 링크\n안그래도 괴랄한데, 쿼리 종류만 121가지가 있어서 더 괴랄하다. 하지만 잘 보면 쿼리의 종류는 3가지만 있다는 것을 알 수 있다.\n1~11 쿼리 - 부분 배열을 한 개의 축을 제외한 초공간에 대칭 12~66 쿼리 - 부분 배열을 두 축의 평면을 기준으로 반시계방향으로 한 번 회전 67~121 쿼리 - 두 축 a, b를 고르고, 전체 배열을 a = b에 대해 대칭 입력 조건에 첫 번째와 두 번째 쿼리는 최대 1,111개만 등장한다는데, 세 번째 쿼리는 그런 말이 없다(총 쿼리 수 111,111). 이 말은 첫 번째와 두 번째 쿼리는 배열 전체를 순회해도 되는데, 세 번째 쿼리는 그럴 수 없다는 것을 의미한다. 일단은 세 번째 쿼리부터 보자.\n3. 67~121 쿼리 방정식이 나오는데, 일단 2차원으로 낮춰서 생각해보자.\n점 (a, b)가 직선 y=x에 대칭되는 점은 (b, a) 인것은 쉽게 알 수 있다. 즉, 두 개의 축에 대응되는 값이 서로 바뀐다는 말이다. 그리고 3차원으로 확장해 생각해 보면 나머지 축들은 변화가 없음을 알 수 있다.\n그러면 배열 전체를 순회하면서 대응되는 값만 바꿔주면 될 것 같지만, 위에서 말했듯이 그럴 순 없다. 대신에 축 자체를 바꿔버리는 방법이 있다. 즉, x축을 y축으로, y축을 x축으로 바꾸는 것이다. 그리고 나중에 연산에 x축이 필요할 때는 y축을 쓰고, y축이 필요할 때는 x축을 쓰는 방식이다.\n이것을 구현하기 위해 변환 테이블을 만들자. 현재 축 → 배열의 축 으로 바꾸는 cvtDim[]과 배열의 축 → 현재 축 으로 바꾸는 invCvt[]배열을 만든다. 만약 축이 바뀌면 해당 현재 축에 대응되는 배열의 축이 바뀌는 것이므로 cvtDim[a]와 cvtDim[b]를 바꾸고, 바뀐 것에 맞게 invCvt[]도 수정해주면 된다.\n1. 1~11 쿼리 배열을 초공간에 대칭한다는 말이 무슨 의미인지 모르겠다. 다행히 예제 1번이 그림으로 설명이 되어 있으므로 이것을 참고해보자.\n1번 쿼리이기 때문에 m축을 제외한 초공간에 대칭이고, 범위는 \\( 1 \\le m \\le 3, 2 \\le w \\le 4 \\) 다. 나머지 축들은 크기가 1이기 때문에 무시하고, m축과 w축을 평면에 수직으로 배치하면 그림처럼 2차원 배열로 표현된다. 점선 영역이 쿼리에 대응되는 영역인데, 연산 결과 m축 index만 뒤집히는 것을 볼 수가 있다. 이것을 보고,\n다른 축들의 index는 변하지 않고, 제외된 축의 index만 뒤집히는 것이 아닐까?\n라고 유추할 수 있다. 3차원에서 생각을 해보면, xy평면에 대칭을 하면 x랑 y값은 바뀌지 않고 z값만 뒤집히게 되므로 위 추측은 유효하다고 생각할 수 있다. (증명은 못하겠지만, 맞았으니까 맞지 않을까?)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 template\u003ctypename T\u003e void swap1(T\u0026 d1, T\u0026 d2, int dim, vector\u003cint\u003e\u0026 a1, vector\u003cint\u003e\u0026 a2, int swapDim, int x1, int x2) { int cdim = invCvt[dim]; if(cdim == swapDim) swap1(d1[x1], d2[x2], dim + 1, a1, a2, swapDim, x1, x2); else { for(int i = a1[cdim]; i \u003c= a2[cdim]; ++i) { swap1(d1[i], d2[i], dim + 1, a1, a2, swapDim, x1, x2); } } } template \u003c\u003e void swap1(ll\u0026 d1, ll\u0026 d2, int dim, vector\u003cint\u003e\u0026 a1, vector\u003cint\u003e\u0026 a2, int swapDim, int x1, int x2) { swap(d1, d2); } void q1(vector\u003cint\u003e\u0026 a1, vector\u003cint\u003e\u0026 a2, int dim) { int gap = a2[dim] - a1[dim] + 1; for(int i = 0; i \u003c gap / 2; ++i) { swap1(arr, arr, 0, a1, a2, dim, a1[dim] + i, a2[dim] - i); } } 뒤집는 것은 범위의 양쪽 끝부터 서로 바꿔주면 된다. 뒤집는 축(swapDim)이면 처음에 정한 2개의 index에 접근하고, 아니면 해당 영역을 전부 순회하면 된다. 주의할 점은 순회할 때 축(dim)은 배열의 축이므로 배열의 축 → 현재 축으로 변환하고, 이 축을 기준으로 데이터를 가져오거나 연산을 해야 한다 (데이터가 현재 축 기준이니까).\n2. 12~66 쿼리 두 축의 평면을 기준으로 반시계방향으로 회전하는 것이기 때문에, 두 축을 제외한 다른 축들은 바뀌지 않는다는 것을 생각할 수 있다. (잘 모르겠다면 3차원에서 배열이 xy평면에 회전한다고 생각해보자. x, y값만 바뀌고 z값은 바뀌지 않는다.)\n반시계 방향으로 회전하는 것은 위 그림처럼 생각하면 된다. 먼저 맨 바깥쪽 경계를 회전시키고, 그다음 안쪽으로 들어가면서 회전시키면 된다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 template \u003ctypename T\u003e void mv(T\u0026 src, T\u0026 dst, int dim, vector\u003cint\u003e\u0026 a1, vector\u003cint\u003e\u0026 a2, int rdim, int ddim, int r, int d, int dr, int dd) { int cdim = invCvt[dim]; if(cdim == rdim) { mv(src[r], dst[r + dr], dim + 1, a1, a2, rdim, ddim, r, d, dr, dd); } else if(cdim == ddim) { mv(src[d], dst[d + dd], dim + 1, a1, a2, rdim, ddim, r, d, dr, dd); } else { for(int i = a1[cdim]; i \u003c= a2[cdim]; ++i) { mv(src[i], dst[i], dim + 1, a1, a2, rdim, ddim, r, d, dr, dd); } } } template \u003c\u003e void mv(ll\u0026 src, ll\u0026 dst, int dim, vector\u003cint\u003e\u0026 a1, vector\u003cint\u003e\u0026 a2, int rdim, int ddim, int r, int d, int dr, int dd) { dst = src; } 인접한 원소끼리 swap을 해도 되지만, 그냥 새로운 배열에 복사했다. swap 함수와 비슷한 느낌으로 작성하면 된다. 두 개의 축에서만 이동하기 때문에 이동할 축(rdim, ddim)과 이동할 위치(r, d), 얼마만큼 이동할지(dr, dd)를 정하고 해당 축인 경우 이동시키면 된다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 void q2(vector\u003cint\u003e\u0026 a1, vector\u003cint\u003e\u0026 a2, int rdim, int ddim) { int rst = a1[rdim], red = a2[rdim]; int dst = a1[ddim], ded = a2[ddim]; cp(arr, tmp, 0); while((rst \u003c red \u0026\u0026 dst \u003c ded)) { // down for(int i = dst; i \u003c ded; ++i) { mv(arr, tmp, 0, a1, a2, rdim, ddim, rst, i, 0, 1); } // right for(int i = rst; i \u003c red; ++i) { mv(arr, tmp, 0, a1, a2, rdim, ddim, i, ded, 1, 0); } // up for(int i = ded; i \u003e dst; --i) { mv(arr, tmp, 0, a1, a2, rdim, ddim, red, i, 0, -1); } // left for(int i = red; i \u003e rst; --i) { mv(arr, tmp, 0, a1, a2, rdim, ddim, i, dst, -1, 0); } rst++; red--; dst++; ded--; } swap(arr, tmp); } 위에서 작성한 mv함수를 이용해 tmp배열에 이동한 값을 넣어준다. 영역의 바깥쪽 테두리를 회전시키고, 영역의 양쪽 끝을 한 칸씩 줄여 다음 테두리를 회전시키는 방식을 쓰면 된다.\n출력하기 출력을 현재 축을 기준으로 출력을 해야 하기 때문에 배열을 그대로 출력할 수는 없다. 매번 대응되는 배열 원소에 접근해서 출력해도 되지만, 현재 축을 기준으로 하는 배열을 새로 만들어서 그곳에 값을 넣고 새로운 배열을 출력했다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 template \u003ctypename T\u003e void init2(T\u0026 d1, int dim) { d1.resize(dimsz[cvtDim[dim]]); for(int i = 0; i \u003c dimsz[cvtDim[dim]]; ++i) { init2(d1[i], dim + 1); } } template \u003c\u003e void init2(ll\u0026 d1, int dim) {} init2(arr2, 0); dim은 현재 축인데, dimsz[]는 배열 축 기준이기 때문에 현재 축 → 배열의 축으로 변환해서 크기를 가져와야 한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 template \u003ctypename T\u003e void insert(T\u0026 d1, int dim, vector\u003cint\u003e\u0026 curi, ll v) { int i = cvtDim[dim]; insert(d1[curi[i]], dim + 1, curi, v); } template \u003c\u003e void insert(ll\u0026 d1, int dim, vector\u003cint\u003e\u0026 curi, ll v) { d1 = v; } template \u003ctypename T\u003e void get(T\u0026 d1, int dim, vector\u003cint\u003e\u0026 curi) { for(int i = 0; i \u003c dimsz[dim]; ++i) { curi.push_back(i); get(d1[i], dim + 1, curi); curi.pop_back(); } } template \u003c\u003e void get(ll\u0026 d1, int dim, vector\u003cint\u003e\u0026 curi) { insert(arr2, 0, curi, d1); } vector\u003cint\u003e curi; get(arr, 0, curi); 이제 get함수를 통해 원래 배열을 순회하면서 각 축의 index를 저장한다. 그리고 insert함수에서는 현재 축 → 배열의 축으로 변환하고 해당 축의 index를 가져와서 해당 위치에 접근해 값을 저장한다.\n축 변환이 상당히 헷갈리는데, insert 함수에서의 dim은 현재 축이고, curi 배열은 배열의 축 기준이기 때문에 dim을 배열의 축으로 변환해야 현재 축에 대응되는 배열의 축 index를 가져올 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template \u003ctypename T\u003e void print(T\u0026 d1, int dim) { for(int i = 0; i \u003c dimsz[cvtDim[dim]]; ++i) { print(d1[i], dim + 1); } if(dim == 10) cout \u003c\u003c \"\\n\"; } template \u003c\u003e void print(ll\u0026 d1, int dim) { cout \u003c\u003c d1 \u003c\u003c \" \"; } print(arr2, 0); 새로 만든 배열로 출력을 한다. 가장 마지막 축만 일자로 출력하기 때문에 이전 축에서 줄바꿈을 해준다.\n소스 코드\n","description":"","tags":[],"title":"하이퍼 시리즈 정복하기","uri":"/posts/2021/solving-hyper-problems/"},{"categories":["Algorithm"],"content":"2021 ICPC Seoul Regional에서 K번으로 Stock Price Prediction이라는 문제가 나왔다. 실제 대회에서는 못 풀었는데, 알고보니 최근에 비슷한 문제 (BOJ 20298 - 파인애플 피자, BOJ 3308 - Matching, SCPC 2021 예선 2차 4번 - 패턴 매칭)가 있는, Well-known이라고 한다. 어쩐지 많이 풀더라…\nBOJ 23576 - Stock Price Prediction BOJ 링크\n문제 내용이 긴데, 간단히 요약하자면\nx 배열의 rank(가장 작은 값부터 0, 1, ..로 바꾸는 것)가 있을 때, y 배열의 sub-배열들 중에 rank 값이 x 배열의 rank 값과 같은 sub-배열의 위치들을 전부 출력하면 된다.\n문자열 매칭 알고리즘을 쓰면 될 것 같긴 한데, 문제는 y배열의 sub-배열이 바뀌면서 같은 값이라도 rank가 달라질 수가 있다는 점이다. 하지만 KMP를 변형하면 해결이 가능하다! KMP에서 문자가 같은지 비교하는 부분만 수정하면 되는데, 이 문제에서는\n두 문자열에서 문자가 각자 하나 추가될 때, 추가된 문자보다 작은 문자의 수와 큰 문자의 수가 두 문자열이 서로 같은지 확인하면 된다.\nproof) 문자열에 문자 c가 추가된다 했을 때, c보다 작은 문자의 수를 lcnt, 큰 문자의 수를 gcnt라 하자. 이제 rank가 어떻게 변하는지 보면 c보다 작은 문자들: c가 추가되어도 rank에 변화가 없음 c: 작은 문자들 다음이므로 lcnt c보다 큰 문자들: c에 의해 한 칸씩 밀리므로 +1 이제 두 문자열의 lcnt와 gcnt가 서로 같다면 바뀌는 rank도 전부 같게 되므로 두 문자열은 그대로 서로 같아진다. 문자의 수는 Segment Tree를 이용해 \\( O(logN) \\)에 셀 수 있고, 전체 시간복잡도는 \\( O((N + M) logN) \\)이다. 주의할 점은 일치하지 않아서 fail함수를 실행하고 문자열을 옮길 때 앞에 있는 문자들을 Segment Tree에서 제거해줘야 한다.\n소스코드\n위 방식으로 앞에서 언급한 BOJ 20298 - 파인애플 피자, BOJ 3308 - Matching 문제도 풀 수 있다. 전자는 y 배열이 원형인 것만 고려하면 같은 문제고, 후자는 x 배열 입력 방식만 조금 다른 것을 빼면 같은 문제다.\nSegment Tree 없이 풀기 - 배열에 중복이 없는 경우 위 방식처럼 Segment Tree를 이용해 풀면 시간제한이 빡빡하다. Fenwick Tree나 바텀업 Segment Tree로는 통과하지만, 탑다운 Segment Tree로는 어려울 수도 있다. 하지만 저 3문제 중에서 가장 먼저 나온 Matching 문제의 해설을 찾아봤는데, Segment Tree 없이 \\( O(N + M) \\)으로 푸는 방법이 존재하고, 그것이 정해라고 한다!\nBOJ 3308 - Matching BOJ 링크\n이 문제는 위 문제랑 거의 같지만 입력 형식이 조금 다르고, 배열에 중복이 없고, N의 범위가 1,000,000으로 커졌다.\nx배열은 읽어오면서 x[v - 1] = i;로 넣어주면 된다. 이제 KMP에서 문자가 같은지 비교하는 부분을 다음과 같이 수정하면 된다.\nx배열 기준으로 문자 c가 추가되고, 문자 c보다 앞에 있는 문자들 중에 c 다음으로 작은 문자의 위치를 lpos, c 다음으로 큰 문자의 위치를 gpos라 할 때, 대응되는 y배열의 lpos, gpos의 문자(lc, gc)와 추가되는 문자 c2의 대소관계가 lc \u003c c2 \u0026\u0026 c2 \u003c gc 인지 확인한다.\n말로는 설명하기 까다로워서 그림으로 예시를 들어 설명한다. 현재 빨간색 위치를 검사하는 단계이다. 이때 x배열의 문자는 3이고, 3 다음으로 작은 1의 위치를 lpos, 3 다음으로 큰 4의 위치를 gpos로 정한다. 이제 y배열에서 대응되는 값들의 대소관계를 비교해, 만족하면 다음으로 넘어가고, 아니면 x배열을 이동시킨다.\n대략적인 proof) 바로 다음으로 작은/큰 문자들의 대소관계를 비교하기 때문에, 만약 저 대소관계를 만족한다면 남은 다른 문자들은 전부 x[lpos]보다 작거나 x[gpos]보다 크게 된다. 이러면 결국 위에서 언급한 lcnt와 gcnt도 두 문자열이 서로 같게 되고, 위의 증명을 사용할 수 있다. 이제 범위로 쿼리를 날릴 필요 없이 lpos, gpos에 대응되는 값만 가져오면 돼서 \\( logN \\)을 없앨 수 있다. 하지만 각 위치에 대응되는 lpos, gpos를 그냥 \\( O(N^2) \\)에 구하게 되면 오히려 더 느려지므로 빠르게 구하는 방법을 생각해야 한다. 이는 Doubly Linked List를 이용해 \\( O(N) \\)에 구할 수 있다.\n일단 Linked List에 0부터 N-1까지 순서대로 넣어준다. 그리고 x배열을 뒤에서부터 돌면서 Linked List를 이용해 해당 값보다 한 단계 작은/큰 값을 찾고, 해당 값의 위치(lpos, gpos)를 구한다. 그리고 다음 루프로 넘어가기 전에 해당 값을 Linked List에서 지워준다.\n소스코드\nSegment Tree 없이 풀기 - 배열에 중복이 있는 경우 만약 배열에 중복이 있는 경우라면 위의 방법을 그대로 사용하거나, 크거나 같음/작거나 같음으로 하면 안 맞는 경우가 생긴다. 대신에 만약 추가되는 문자가 이미 존재하는 경우에는, 이미 존재하는 문자의 위치를 찾고(spos), y 배열에서도 같은지 확인하면 된다. 생각해보면 이미 있는 문자가 또 추가되는 경우에는, 다른 문자들의 rank가 변하지 않으므로 그냥 실제 매칭되는 문자도 같은지만 확인하면 된다.\n이것을 처리하기 위해서 Linked List에 추가로 해당 값의 개수인 cnt정보도 넣어둔다. x배열을 뒤에서부터 돌면서 만약 해당 값의 cnt가 2 이상이라면 해당 위치 앞에 같은 값이 있다는 의미이므로, 해당 위치에 spos를 기록한다. spos는 미리 해당 값의 가장 왼쪽 위치로 찾아두면 된다. 기록 후 해당 값의 cnt를 감소시키고 0이 된다면 Linked List에서 지워준다.\n확인하는 함수에서는 먼저 spos가 기록되어 있는지 확인 한 후, 되어 있으면 해당 위치와 spos 위치의 문자가 같은지 비교하면 되고, 기록이 안 되어 있으면 기존 방식을 쓰면 된다.\n소스코드 (BOJ 23576 - Stock Price Prediction)\n소스코드 (BOJ 20298 - 파인애플 피자)\n얼마나 빨라질까? Stock Price Prediction 문제는 약 2.72배 빨라졌다.\n파인애플 피자 문제는 약 3.4배 빨라졌다.\nMatching 문제는 약 3.1배 빨라졌다.\n전체적으로 약 3배 정도 빨라졌음을 볼 수 있다.\n","description":"","tags":[],"title":"Stock Price Prediction 문제를 Segment Tree 없이 풀기","uri":"/posts/2021/solve-stock-price-prediction-problem-without-segment-tree/"},{"categories":["Algorithm"],"content":"ABC216G - 01Sequence의 에디토리얼을 보는데, 문제를 소 게임(牛ゲー) 형태로 변형해서 풀면 된다고 나와있다. 처음 보는 유형이라서 검색해보니까 특이한 유형이라서 정리해본다.\nBOJ 7040 - 밥 먹기 BOJ 링크\n소 게임은 위 문제에서 나온 풀이를 일본에서 부르는 말인 것 같다. 개미책(蟻本)으로 알려진 풀이같다. (번역본이 있는데, 속칭 노란책이라 부른다.)\n어떤 주어진 수열이 있고, 이 수열에 제약 조건 \\(x_j - x_i ≤ c_{i,j}\\)들이 있을 때, \\(x_q - x_p\\)의 최댓값을 구하고 싶다. 결론부터 말하자면, 각 수열을 그래프의 노드라고 생각하고 제약 조건들을 \\(i → j\\)로 가는 \\(c_{i,j}\\) 비용의 단방향 간선을 넣고, \\(p\\)에서 \\(q\\)의 최단경로를 구하면 된다.\n이 개념은 간선이 두 노드 사이 거리를 묶어둔다고 생각하면 된다. 위의 그림처럼 a와 c가 7인 줄로 묶여있는데, a와 b, b와 c가 각각 2, 3인 줄로 묶여있으면, a와 c를 최대한 잡아당겨도 주황색 줄에 의해 최대 5까지만 늘어나게 된다. 이 최대값은 a와 c의 최단경로로 구할 수 있다.\n부등호가 반대인 경우에는 식들을 적절히 넘겨서 방향을 바꿔주면 된다. 그러면 간선의 방향은 반대가 되고, 비용은 음수가 된다. 이는 두 노드 사이 거리가 최소한 간선 비용 이상이어야 한다는 것을 말한다. 만약 두 노드의 최대 거리가 이 비용보다 작으면, 음수 사이클이 생기게 돼서 불가능한 경우가 된다.\n좀 더 자세한 증명은 밑에 참고 자료에서 볼 수 있다(일본어).\n위 문제에서 제약 조건들을 살펴보면,\n일단 번호 순으로 줄을 서기 때문에 \\(x_{i+1} - x_i ≥ 0\\) 서로를 좋아하는 소는 \\(x_b - x_a ≤ c_{a, b}\\) 서로를 싫어하는 소는 \\(x_b - x_a ≥ c_{a, b}\\) 3가지로 나눌 수 있다. 이 제약 조건들로 간선을 그어보면,\n\\(i+1 → i\\)로 비용 \\(0\\)인 간선 \\( (x_i - x_{i+1} ≤ 0) \\)\n\\(a → b\\)로 비용 \\(c_{a, b}\\)인 간선 \\( (x_b - x_a ≤ c_{a, b}) \\)\n\\(b → a\\)로 비용 \\(-c_{a, b}\\)인 간선 \\( (x_a - x_b ≤ -c_{a, b}) \\)\n긋고 \\(1\\)에서 \\(n\\)의 최단경로를 구하면 된다. 음수인 간선이 있기 때문에 벨만-포드를 사용해야 한다. 만약 도달하지 못해서 INF값이라면 \\(-2\\), 음수 사이클이 생기면 \\(-1\\)을 출력하면 된다.\n소스코드\nABC216G - 01Sequence 문제 링크\n\\([L, R]\\)에서 \\(1\\)의 개수가 \\(x\\)개 이상이라는 말은, \\(0\\)의 개수가 \\(R-L+1-x\\)개 이하라는 말과 동치이다. 이제 \\(B_n\\)을 \\(A1,A2,…,An\\)까지 \\(0\\)의 개수라고 정의하자. 그러면 \\(B_R - B_{L-1} ≤ R-L + 1 - X\\) 라는 부등식을 얻을 수 있다 (Prefix sum을 생각하면 된다).\n여기에 추가로\n\\(B_i - B_{i+1} ≤ 0\\) \\(B_{i+1} - B_i ≤ 1\\) \\(B_0 = 0\\) 가 성립한다. 이러면 \\(B_n\\)의 최댓값을 구할 수 있고 전체에서 최소 1의 개수를 알 수 있다(\\(0\\)의 최댓값 → \\(1\\)의 최솟값). 이제 \\(1\\) ~ \\(n\\)범위에서 최소 1의 개수를 알았으니, 뒤에서부터 보면서 \\(B_{i}\\)와 \\(B_{i - 1}\\) 값이 같으면 1, 다르면 0을 넣으면 된다. 간선의 비용들이 전부 양수이므로, 다익스트라 알고리즘을 사용해도 된다.\n소스코드\n실은 이 문제는 그리디 + 세그먼트 트리로 푸는 것이 더 쉽다. 쿼리를 \\(R\\)이 작은 순으로 정렬하고, 현재 해당 구간에서 \\(1\\)의 개수를 세고 부족한 1의 개수만큼 현재 구간의 오른쪽부터 채워주면 된다. 넣어줄 \\(1\\)의 위치는 스택을 이용해 저장하면 된다. 소스코드\n참고 자료 https://qiita.com/tanabe13f/items/6c723c29a121de760790\n","description":"","tags":[],"title":"ABC216G - 01Sequence와 소 게임(牛ゲー)","uri":"/posts/2021/abc216g-and-cow-game/"},{"categories":["Algorithm"],"content":"최근에 재미있는 풀이를 발견해서 정리해본다. 이 풀이는 결과값(정답)을 구해야 하는데, 결과값을 구하기 위해 계산하는 과정에서 결과값이 필요한 경우를 말한다. 말이 이해가 안 갈수가 있는데, 밑에 문제를 보면 어떠한 유형인지 알 수 있을 것이다.\n푸는 방법을 간단히 요약하자면, 결과값을 parametric search를 이용해 임의로 정하고, 계산해서 나온 결과값이랑 임의로 정한 결과값을 비교해 결과값을 찾으면 된다.\nBOJ 21343 - Great Expectations BOJ 링크\n위 문제를 요약하면, 스피드런을 하는데 특정 시간마다 trick이 있다. 이 trick은 어려워서 특정 확률로 실패할 수 있는데, 실패할 경우 추가 시간 패널티를 얻게 된다. 그리고 이렇게 추가 시간 패널티를 더해서 r시간보다 작아야 한다. 그리고 추가로 스피드런을 하다가 리셋을 할 수 있는데, 이러면 처음부터 다시하나 흘러간 시간은 그대로이다(스피드런을 할 때 리셋을 하고 다시 녹화를 한다고 생각하면 된다). 이럴때 스피드런을 완료하는데 걸리는 시간의 기댓값을 최소화하는 문제다.\n요약한 것을 봐도 잘 이해가 안 가는데, 예제입력 1을 보면 이해가 조금은 된다.\n일단 dp식을 \\( dp[i][j] = i\\)번째 trick부터 끝까지 진행하고, \\( j\\)만큼 패널티를 먹을 때 최소 기댓값 으로 정하자.\n\\(dp[i][j]\\)를 구할 때 먼저 \\(t[i] - t[i-1]\\)를 더한다. 그래야 다음 \\(i-1\\)에서 기댓값을 구할 때, \\(i-1이후~\\) 값을 구할 수 있기 때문이다. 그리고 이제 성공할 때 경우하고 실패할 때 경우의 기댓값을 구해야 한다.\n만약 성공하는 경우에는 패널티가 없기 때문에, 그냥 \\(dp[i+1][j]\\)를 더하면 된다. 만약 실패하는 경우에는 패널티를 먹고 계속 진행하거나, 리셋을 해서 처음부터 다시 하는 경우가 있을 수 있다. 전자는 단순히 \\(dp[i+1][j+err[i]] + err[i]\\)를 더하면 되는데, 후자는 딱히 이전 dp값으로 표현을 할 수가 없고, 그냥 결과값을 넣어야 한다. 식을 정리하면,\n\\[dp[i][j] = t[i] - t[i-1] \\] \\[+ p[i] * dp[i+1][j] \\] \\[+ (1-p[i]) * min(dp[i+1][j+err[i]] + err[i], 결과값)\\]\n이 된다. 결과값을 구하기 위해 dp를 계산하는데 dp 계산식에 결과값이 들어가는 모순?이 생겨버린다. 이 문제를 해결하기 위해, 결과값을 \\(k\\)로 정하고, 계산한 결과값을 \\(k\\)랑 비교해서 parametric search로 찾으면 된다. 만약 k보다 더 작은 결과값이 나오면, 실제 결과값은 더 작을 것이기 때문에 더 작게 조절하고, 더 큰 결과값이 나오면 실제 결과값은 더 클 것이기 때문에 더 크게 조절하면 된다.\n소스코드\nBOJ 6141 - Sightseeing Cows BOJ 링크\n\\( \\frac { \\sum { \\text {fun values} } } { \\sum{ \\text { path cost } } } \\) 를 최소화하는 사이클을 찾는 문제이다.\n실은 풀이가 완전히 이해가 되진 않았는데, 그래도 써본다.\n일단 \\(결과값 = \\frac { \\sum \\text{fun values} } { \\sum \\text{path cost} } \\) 이 식을 변형하면 \\(결과값 * \\sum { \\text{path cost}} - \\sum { \\text { fun values } } = 0 \\) 이 된다. 이렇게 변형한 이유는 그래야 경로를 돌면서 \\( 결과값 * \\text{edge cost} - \\text{fun value} \\) 로 그때 그때 업데이트가 가능하게 되서 간선의 비용을 바꿀수 있기 때문이다.\n변형된 계산식으로 계산했을 때, 만약 음수 사이클이 나온다면 변형 식의 값이 음수라는 뜻이고, 이는 \\(k\\)보다 실제 결과값이 더 크다고 볼 수 있다(그래야 변형 식의 값이 커지기 때문에). 반대로 음수 사이클이 없다면 실제 결과값이 더 작다고 볼 수 있다. 이것을 parametric search로 실제 결과값을 찾으면 된다.\n소스코드\n꽤나 신선한 방법이라서 이러한 풀이로 푸는 문제들을 더 풀어보고 싶은데, 딱히 이런 방법을 표현하는 용어도 없어서 찾기가 어렵다. 그나마 이분 탐색/매개 변수 탐색 태그로 찾아보면 좀 나올지도?\n","description":"","tags":[],"title":"연산에 결과값을 써야 할 때 결과값을 Parametric Search로 구하기","uri":"/posts/2021/find-answer-using-parametric-search-when-use-answer-in-calculation/"},{"categories":["Algorithm"],"content":"최근에 경로에서 최소/최대 간선을 최대/최소화 하는 알고리즘을 배웠는데, 개념이 재미있어서 정리해본다.\n최소 간선을 최대화 BOJ 1939 - 중량제한\n위 문제를 요약하면 경로에서 최소 간선을 최대화하는 문제이다.\n기본적인 개념은 MST를 크루스칼 알고리즘을 이용해서 구할 때 만들어지는 유니온 파인드 트리를 이용하는 것이다. 최소 간선을 최대화 할때는 Maximum Spanning Tree를 이용한다. MST를 만드는 도중을 생각해보자.\n현재 정점들이 연결된 A 컴포넌트와 B 컴포넌트가 있다. 이제 다음 점선 간선을 추가하는데, 이때 A 컴포넌트의 정점 중 하나랑 B 컴포넌트의 정점 중 하나라고 하자. 이때, 선택된 두 정점간의 경로의 최소 간선의 최대값은 무조건 해당 간선이 된다. 왜냐하면 해당 간선을 추가하면서 경로가 생기게 되고, 남은 간선들은 전부 현재 간선보다 작거나 같기 때문에 남은 간선을 탈 필요가 없기 때문이다. 같은 이유로 A 컴포넌트의 아무 정점과 B 컴포넌트의 아무 정점간의 경로도 고정이 된다.\n결국 A 컴포넌트와 B 컴포넌트를 연결하는 다른 간선들은 전부 무시해도 되기 때문에, 그냥 해당 간선을 각 컴포넌트의 루트 노드로 옮겨서 연결하면 된다. 즉, 유니온 파인드를 하는 과정이랑 똑같다. 보통 유니온 파인드를 구현할 때는 노드의 부모값만 저장하는데, 여기에 추가로 간선의 비용도 저장한다.\n이렇게 해서 유니온 파인드 트리를 만들고 해당 트리에서 경로를 이용하면 최소 간선의 최대값을 구할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 int par[10001], r[10001], dis[10001]; int find(int v) { while(par[v] != v) { v = par[v]; } return v; } void uni(int u, int v, int w) { int ur = find(u); int vr = find(v); if(ur == vr) return; if(r[ur] \u003e r[vr]) swap(ur, vr); par[ur] = vr; if(r[ur] == r[vr]) r[vr]++; dis[ur] = w; } int query(int u, int v) { int res = 0; while(u != v) { if(dis[u] \u003c dis[v]) swap(u, v); res = dis[u]; u = par[u]; } return res; } 유니온 파인드는 그냥 쓰면 느려질 수 있기 때문에 Union by rank를 이용한다. Path decomposition은 트리의 구조가 깨지기 때문에 사용하지 않는다. 간선의 비용은 dis[] 배열에서 부모로 올라갈 때 비용으로 저장한다.\n이렇게 트리를 만들고 난 뒤, 경로를 찾을 때는 LCA를 찾으면 되는데, 간선의 비용이 큰 것부터 차례대로 올라가면 된다. 이것이 되는 이유는, 트리를 만들 때 간선의 비용이 큰 쪽에서 작은 쪽으로 연결하고, Union by rank를 할 때 서로 합쳐지면서 루트가 갱신되기 때문에 무조건 위의 간선 비용이 아래 간선 비용보다 작을 수 밖에 없기 때문이다. 큰 비용이 무조건 작은 비용보다 아래에 있거나 같은 높이에 있기 때문에, 큰 비용인 정점만 옮기면 자연스럽게 LCA로 다가가게 된다. 설명하기가 좀 어려운데… 직접 손으로 그려보면 감이 잡힐 것이다.\n물론 평소 LCA를 구할 때 처럼 Sparse table을 만들어서 구해도 된다. 하지만 어차피 Union by rank를 이용했기 때문에, 트리의 높이는 logN이라서 LCA를 그냥 찾아도 logN에 찾을 수 있다.\n소스코드\n최대 간선을 최소화 BOJ 1396 - 크루스칼의 공\n이 문제는 앞의 문제와는 반대로 최대 간선의 최소값을 구해야 한다. 이는 간단하게 Maximum Spanning Tree를 Minimum Spanning Tree로 바꾸면 된다. 물론 이러면 트리에서 올라갈수록 간선 비용이 커지므로, 간선의 비용이 작은 것부터 차례대로 올라가야 한다.\n이 문제는 추가로 해당 온도일 때 움직일 수 있는 정점의 개수도 구해야 한다. 여기서 그냥 단순하게 LCA에서 트리의 크기로 출력하면 틀리게 된다.\n예제 입력 1의 데이터를 처리한 후 트리의 모습이다. 여기서 (4, 5)를 쿼리로 날리면 결과값은 3이고, LCA는 5번 노드가 된다. 5번 노드의 크기는 5지만, 3의 값으로는 2번 노드로 갈 수 없기 때문에 실제 정답은 2가 나와야 한다. 그래서 LCA의 자식들로 갈 수 있는지 확인 후 갈 수 있는 자식의 크기들만 더하면 되는데, 역시 그냥 순차탐색을 하게 되면 시간 초과가 나게 된다. 더 빠르게 찾을 수 있는 방법을 생각해야 한다.\n여기서 트리를 만들 때 간선의 비용이 작은 것에서 큰 것으로 이용한다는 점을 이용한다. 유니온을 하면서 자식이 달라붙을 때는 무조건 간선의 비용이 점점 커지는 방향으로 추가가 된다. 이 점을 이용해서, 자식이 붙을 때 마다 간선의 비용과 현재 자식들의 크기 + 해당 자식의 크기 (Prefix sum) 를 저장하고, 찾을 때 그냥 이분탐색(lower_bound()를 쓰면 된다)으로 찾으면 된다.\n소스코드\n관련 문제 BOJ 5542 - JOI 국가의 행사\nBOJ 10264 - Particle Swapping\n","description":"","tags":[],"title":"DSU + MST로 경로에서 최소/최대 간선 구하기","uri":"/posts/2021/find-min-or-max-edge-in-path-using-dsu-and-mst/"},{"categories":["Algorithm","Codeforces","Contests"],"content":"\nEducational Codeforces Round 106 (Rated for Div. 2)에 참가했다. 2일 연속으로 하는거라서 할까말까 고민하다가 했는데 결과가 좋지 않다. 걍 쉴껄…\n전체 Code\nA. Domino on Windowsill 그림으로 표현하면 이런 모양이 된다. 이러면 주황색 영역 왼쪽에는 하얀 도미노를 min(k1, k2)개 놓을 수 있고, 오른쪽에는 검은 도미노를 n - max(k1, k2)를 놓을 수 있다. 그리고 주황색 영역에서는 하얀/검은 도미노를 각각 abs(k1 - k2) / 2만큼 놓을 수 있다. 이 값을 w, b하고 비교하면 된다.\nB. Binary Removals 지울때 무조건 한 칸 이상 띄우고 지워야 하기 때문에, 붙어있는 경우를 체크해야 한다는 점을 알 수가 있다. 왜냐하면 00, 11이 무조건 0, 1로 남기 때문이다. 이것을 알고나면 11다음에 00이 나오는지 확인만 하면 된다는 것을 알 수가 있다(둘 다 하나는 남기 때문에 무조건 1….0 구조가 나오기 때문).\nC. Minimum Grid Path 일단 방향이 왔다갔다 하기 때문에 배열의 홀수 번/짝수 번째끼리 묶어서 생각할 수 있다. 그리고 목록이 있으면 가장 작은 값에 거리를 다 몰아주고 나머지는 1만 주는 경우가 가장 작다는 것을 발견해야 한다. 본인은 예제 데이터 설명을 보고 유추했다.\n그리디를 증명하는 방법은 보통 최적의 해인 경우를 가정하고 반례가 있는지 찾아보면 된다. 위 경우는, 가장 작은 값에 있는 거리를 다른 값에게 줬을 때 무조건 커지거나 같아지기 때문에 반례가 없어서 증명된다. 이제 이것을 dp처럼 구현하면 된다. i번째까지 사용할 때, 짝수/홀수번째 수의 합(sum1, sum2)과 가장 작은 것(min1, min2)과 개수(cnt1, cnt2)를 구하고, min1*(n-cnt1) + min2*(n-cnt2) + (sum1-min1) + (sum2-min2)를 구하고 이 값들 중 최소값을 출력하면 된다.\nD. The Number of Pairs 미친듯이 삽질하다가 마지막에 아이디어가 떠올랐는데 못 푼 문제다…\n일단 LCM이 GCD에서 자연수 k를 곱한 형태라는 것을 알아야 한다. 그러면 LCM = kGCD로 바꿀 수 있고, GCD에 대한 식으로 바꾸면 GCD = x/(ck - d)가 되고, 이 값이 자연수로 나오면 가능한 경우가 된다. 결국 ck - d가 x의 약수여야만 가능한 것이고, 약수는 sqrt(x)번 돌려서 찾을 수 있다.\n위의 방식으로 k의 값을 구하면 이 k를 두 수에 적절히 분배하는 경우의 수를 구하면 되는데, k를 소인수분해해서 2^소수 종류 개수(각 소수를 왼쪽/오른쪽으로 분배하는 경우)로 구할 수 있다. 이때 2^3처럼 같은 소수가 여러개 있는 경우 두 개로 쪼개지 말아야 하는데, 쪼개는 경우 GCD가 증가하기 때문이다.\n이때 어제 E1문제처럼 소인수분해를 할 때 sqrt(k)로 하면 시간초과가 나게 된다. 그래서 오일러의 체(에라토스테네스의 체 변형)을 이용해야 한다. 이걸 써도 시간이 아슬하긴 하다.\nPS: System test에서 fail이 뜨길래 long long을 int로 바꾸니 통과했다. 시간이 매우 빡빡해서 그런 것 같다. long long은 꼭 필요할 때만 쓰는게 좋을 것 같다.\n","description":"","tags":[],"title":"Educational Codeforces Round 106 (Rated for Div. 2)","uri":"/posts/2021/edu-codeforce-round-106-div2/"},{"categories":["Algorithm","Codeforces","Contests"],"content":"\nCodeforces Round #708 (Div. 2)에 참가했다. 도중에 사이트가 마비되는 이슈가 있었다. m1버전으로 풀고있었는데 결국 unrated되었다. 중간에 조금 헤매서 잘 못봤는데 다행이다. (망할 정수론)\n전체 Code\nA. Meximization 일단 정렬을 해서 바로 순서대로 출력하면 틀리게 된다. 왜냐하면 중복되는 숫자가 있는 경우 해당 부분에 mex값이 변하지 않기 때문이다.\nex) 0 1 2 2 3 보다 0 1 2 3 2가 더 높은 값을 가진다. 그래서 정렬을 한 다음에 앞에서부터 중복되지 않게 결과값을 넣고, 중복되는 남은 것들을 맨 뒤로 넣으면 된다.\nB. M-arrays 임의의 두 개의 수를 더해서 m으로 나누어지는 경우는 두 수의 m으로 나눈 나머지의 합이 0이거나 m이면 된다.\n그래서 먼저 배열에 넣을 때 modulo m으로 하고 해당 값들의 개수들을 저장한다. 그리고 \u003c1, m-1\u003e, \u003c2, m-2\u003e, …이렇게 앞뒤로 묶어서 개수를 검사한다. 만약 둘 중 하나가 0이라면, 남아있는 수로는 다른 수랑 묶을 수 없기 때문에 전부 별개의 배열로 나눠야 한다. 이경우 개수들을 전부 더해준다.\n둘 다 있는 경우라면, abab나 babab 등 서로 엇갈려서 한 개의 배열로 묶을 수 있다. 묶고 남은 수는 위의 경우처럼 전부 별개의 배열로 나눈다. 이경우 많은 개수 - 적은 개수를 더하면 된다 (정확한 식은, 많은 개수에서 1개를 더 써야 하기 때문에 묶고 남은 개수는 많은 개수 - 적은 개수 - 1, 여기에 아까 묶은 배열 개수 +1). 만약 두 개의 개수가 같은 경우, 남은 개수가 없기 때문에 추가로 +1을 해준다.\n0인 경우 0끼리 다 묶으면 되므로, 0인 경우가 있으면 추가로 +1하면 된다.\nC1. k-LCM (easy version) 생각보다 많이 헤맨 문제였다. 풀이를 떠오르기가 어려운 문제지만, 예제 데이터가 힌트가 되었다.\n일단 최대공배수가 n/2를 넘지 않아야 하기 때문에, 모든 항은 무조건 n/2보다는 작아야 한다. 이 n/2를 가지고 생각을 해보면, 홀수의 경우 (1, n/2, n/2)를 하면 간단히 해결이 가능하다.\n이제 짝수의 경우가 문제인데, 일단 홀수처럼 n/2를 넣어보자, 그러면 (0, n/2, n/2)가 되는데, 여기서 예제 데이터를 보면 2가지 경우가 나온다.\nn/2가 홀수인 경우 n/2에서 1씩 빼서 첫 번째 자리에 넣는다. 그러면 (2, n/2-1, n/2-1)이 되고, 최대공배수는 n/2-1이 된다. n/2가 짝수인 경우 n/2중 하나를 절반으로 나눠서 첫 번째 자리에 넣는다. 그러면 (n/4, n/4, n/2)가 되고, 최대공배수는 n/2가 된다. C2. k-LCM (hard version) 이런 easy/hard문제들은 점수는 비슷한데 완전 다른 알고리즘을 쓰는 경우가 있고, E1이 많이 풀려있길래 E1을 먼저 생각하다가 C2로 돌아왔는데 생각보다 쉽게 풀리는 문제였다… 어쩐지 점수가 작다 했어\n위의 문제에서 3개로 나누는 것을 k개로 나누어야 하는데, 조금만 생각해보면 위의 문제에서 3자리를 제외하고 남은 자리를 1로 채우고, 남은 3자리는 C1처럼 하면 된다.\nC2 문제 하나만 있으면 위 방법을 떠올리기가 쉽지 않았을 것이다. C1 -\u003e C2로 넘어가면서 자연스럽게 풀이를 유도한 것 같다. 이런 컨셉은 괜찮은 것 같다.\nE1. Square-free division (easy version) Perfect square(완전 제곱수)인지 확인하는 방법은, 해당 수를 소인수분해해서 각 소수들의 지수가 모두 짝수이면 된다. 그러면 어떤 수와 곱해서 perfect square가 되려면, 지수가 홀수인 소수들이 같으면 된다는 것을 알수가 있다. 그 소수들이 곱해지면서 지수들은 더해져서 짝수가 되기 때문이다.\n이제 앞에서부터 순회하면서, 이전의 수들과 비교해 perfect square가 되면 현재 수 이전까지로 배열을 자르고, 다시 현재 수를 기준으로 이어서 순회하면 된다. 문제는 이전의 수들을 비교할 때 그냥 비교하면 O(n^2)이기 때문에 시간초과가 나게 된다. 그래서 (2의 지수가 홀수), (2와 3의 지수가 홀수), … 이런 것을 빠르게 찾을 수 있는 방법을 떠올려야 하는데, 비트마스킹을 쓰기에는 소수의 개수가 많기때문에 사용할 수 없다.\n그러다가 어차피 다 소수이기 때문에, 그냥 해당하는 소수들을 곱하면 그 값들은 전부 다 다르기 때문에 비트마스킹과 같은 효과가 나는 것을 알 수가 있다. 이것을 set에 넣고 있는지 확인하면 된다.\nn의 개수가 200000이라 상당히 많기 때문에, 그냥 d의 제곱수만큼 돌아서 소인수분해를 하면 시간초과가 날 수도 있다 (2*10^5 * sqrt(10^7) = 약 6억). 그래서 이 문제에서는 오일러의 체를 쓰는 것을 추천한다. 수의 범위가 10^7이기 때문에 정적배열로 충분히 선언 가능하다. 그래도 나중에 다른 사람들의 풀이를 보니까 제곱수로 풀어도 시간 안에 나오는 것 같다.\n","description":"","tags":[],"title":"Codeforces Round #708 (Div. 2)","uri":"/posts/2021/codeforces-round-708-div2/"},{"categories":["Programming","Etc"],"content":"최근 언리얼 엔진을 이용한 프로젝트를 한 적이 있었다. 언리얼 엔진은 프로그래밍을 할 때 블루프린트를 이용할 수 있지만, 구조가 복잡해지면 가독성이 떨어지기도 하고, 결정적으로 Gameplay Ability System이 블루프린트를 지원하지 않기 때문에 핵심 파트는 C++로 개발하고 있었다.\n본인은 Windows 환경에서 C++을 개발할 때 거의 Visual Studio를 사용한다. 가장 큰 이유는 디버깅하기 편해서지만, Intellisense 기능도 상당 부분 차지한다. 이 기능이 있어야 Syntax highlighting이나 Code completion, Navigation등 여러 편리한 기능들을 쓸 수 있다. 소규모 프로젝트에서는 이 기능들이 잘 작동하지만, 언리얼 엔진 프로젝트는 엔진 소스코드도 참조해서 그런지 매우 느리게 작동한다.\n위 영상처럼 다른 파일을 열 때마다 Intellisense가 코드를 분석하는데 오랜 시간이 걸려서 개발하는데 많이 불편했다.\n그래서 찾아보니까 Visual Assist 또는 ReSharperC++같은 추가 Extension을 많이 사용하는 것 같다. Visual Assist는 지인도 쓰고있고 많이 쓰는 것 같은데… 유료다. 물론 ReSharperC++도 유료지만 JetBrains사 제품들은 학생인증을 하면 무료로 쓸 수 있어서 후자를 선택했다.\n적용하니 12초에서 1초로 매우 빠르게 완료가 된다. 다만 프로젝트를 열 때 플러그인 초기화 + 인덱싱을 하는지 조금 기다려야 한다 (한 1~2분?).\n이외에도 여러 유용한 기능들이 많은데 그중에 본인이 자주 쓰는 것들을 정리해봤다. 단축키 설정은 Visual Studio scheme을 이용한다.\nCode / File template 템플릿 기능은 자주 쓰는 코드 조각들을 미리 정의해서 쉽게 가져다 쓸 수 있는 기능이다. 그중에 본인이 많이 쓰는 것은\nbeg..end - STL container에서 시작과 끝을 지정하는 일이 많은데, 그때 사용한다.\nfori, forr - 각각 순차/역순으로 탐색하는 for문을 만든다.\n이외에도 사용자가 직접 템플릿을 정의해서 만들 수 있다.\nInlay hints JetBrains사 제품에서 많이 볼 수 있는데, 함수를 호출 할 때 매개변수의 이름을 보여주는 기능이다. Python이나 Swift같은 언어처럼 매개변수를 명시적으로 지정할 수는 없지만, hint로 보여주니까 괜찮은 것 같다. 레퍼런스로 넘겨지는 경우에는 [\u0026]를 표시한다.\n개인적으로 이 기능의 최대 강점은 struct를 초기화 할 때 변수들 이름을 보여주는 것이다. {}를 이용해 초기화를 할 때 변수 이름들을 보여줘 값들이 어떤 변수에 들어가는지 바로 알 수 있다.\nSearch everywhere Mac의 Spotlight랑 비슷한 기능이다. Ctrl + T를 누르면 검색창이 뜨는데, 여기에 찾고싶은 것을 입력하면 해당하는 이름의 클래스/함수/변수명을 찾거나, 텍스트를 찾는 기능이다. 솔루션 탐색기를 뒤질 필요 없이 검색해서 바로 찾을 수 있어서 편리하다. 만약에 타입들로만 찾고 싶다면 Ctrl + T를 두 번, 파일명으로만 찾고 싶다면 Ctrl + Shift + T 등 선택적으로도 탐색할 수 있다.\nNavigation 특정한 위치로 이동하는 기능들이다. Alt + ` 를 누르면 위 사진처럼 사용할 수 있는 기능들이 나온다. 자주 사용하는 기능들로는,\nFind usage\nShift + F12를 누르면 해당 함수나 변수가 쓰이고 있는 곳들을 보여준다. Visual Studio에도 있는 기능이지만, 속도는 비교할 수 없을 정도로 빠르다.\nShift + Alt + F12를 누르면 별도의 창이 아닌 바로 볼 수 있다.\nBase / Derived Symbol\n함수나 클래스의 부모 / 자식으로 바로 이동할 수 있다. Alt + Home / Alt + End로 이동 가능하다. Insertion 특정 코드들을 넣을 수 있는 기능이다. Alt + Insert를 누르면 사용할 수 있는 기능들이 나온다. 자주 사용하는 기능들로는,\nCopy and move operations 복사/이동 관련 함수들을 추가해준다. 맴버 변수들도 반영해서 함수가 만들어진다. Overriding / Missing memebers 오버라이딩 할 함수나 추가해야 할 함수들을 추가한다. 하지만 보통 밑에 있는 빠른 수정 기능으로 이용한다. 빠른 수정 코드에 문제가 있거나 수정사항이 있을만한 곳에 물결 표시가 뜨는데, 이를 해결해주는 기능이다. Alt + Enter로 사용할 수 있다. 자주 사용하는 기능들로는,\nSwitch - generate missing case statements\nswitch 값이 enum class같이 정해져 있는 경우, 빠져있는 case들을 자동으로 추가하는 기능이다. Class 수정\n만들어야 할 함수(pure virtual function, …)들을 추가할 수 있다. Function 수정\n구현이 없는 함수에 구현을 추가할 수 있다. including\n코드를 작성하는데 만약 include되지 않은 것을 쓰려하면 자동으로 해당 헤더파일을 include해준다. Refactoring 말 그대로 리펙토링 기능이다. Ctrl + Shift + R로 사용할 수 있다. 자주 사용하는 기능으로는,\nRename\n함수나 변수의 이름을 바꿔주는 기능이다. Ctrl + R, R로 실행할 수 있다. 사용중인 곳에도 자동으로 바뀐다. Change signature\n함수의 이름 뿐만 아니라 선언까지 바꿔주는 기능이다. Ctrl + R, S로 실행할 수 있다. return type, 매개변수 추가 / 수정 / 제거 등 여러가지를 바꿀 수 있다. 이상하게 이 창에서는 입력하는 속도가 상당히 느려진다.\n추가되는 매개변수가 있을 경우, 이 함수를 사용하는 곳에서 어떤 값으로 넣을지 정할 수 있다.\nUnreal Engine support 당연히 언리얼 엔진 기능도 지원한다. 이러한 플러그인을 쓰게 된 계기가 언리얼 엔진 지원 때문이니…\nReflection code completion\n언리얼 엔진에서는 C++에서는 지원하지 않는 리플렉션 기능을 위해 UCLASS, UFUNCTION과 같은 여러 매크로들을 사용한다. 하지만 실제로는 아무 내용도 없는 매크로이기 때문에, Visual Studio에서는 리플렉션 관련 코드들 자동 완성이 되지 않는데, 이러한 매크로들을 자동 완성이 되도록 해준다. UE4 전용 코드 검사\n역시 리플렉션 기능을 위해 매크로를 필수적으로 넣어야 하는 곳들이 있는데, 빠진 곳에 오류를 표시해서 알 수 있게 해준다.\n언리얼 엔진에는 자체적인 코딩 컨벤션이 있는데, 이를 지키지 않을 경우 오류를 표시해준다.\nEtc To-do items\n코드에 있는 TODO들을 모아서 보여주는 기능이다. Ctrl + Alt + D를 눌러 띄울 수 있다. std::make_shared 매개변수\n스마트 포인터를 생성하기 위해서는 보통 std::make_shared나 std::make_unique함수를 많이 사용한다. 근데 이 함수들을 이용하면 생성자의 매개변수들을 에디터에서 볼 수가 없고, 만약에 잘못 넣은 경우 에디터에 바로 나오지 않고 컴파일해야 나오기 때문에 오류를 알아보기가 힘들다. 이러한 단점을 보완해 에디터에서 생성자의 매개변수들을 볼 수 있고, 잘못 넣은 경우 오류를 바로 표시해준다. Extend selection\n선택 범위를 점점 늘려가거나 줄이는 기능이다. 보통 유용하게 쓰는 경우는 함수 파라미터나 인자들을 복사하는 경우이다. Highlight usage in file\n강조하고 싶은 곳에 Shift + Alt + F11을 누르면, 해당 파일 안에서 강조한 것들이 보라색으로 표시가 되는 기능이다. 물론 커서를 가져다대면 파란색으로 강조되긴 한다. break / continue 대상 표시\nbreak나 continue를 쓸 때 해당되는 반복문을 강조해준다. 이게 if나 여러가지가 섞이면 알아보기가 힘든 경우가 많은데, 강조를 해줘서 쉽게 알아볼 수 있다. 이외에도 naming convention, uint test 등 여러 기능들이 있다. 하지만 소소한 단점들도 있는데,\n처음에 프로젝트를 열었을 때 플러그인 로드 + 분석때문에 조금 기다려야 한다. 특히 언리얼 프로젝트인 경우, 맨 처음에 인덱싱하는데 2~5분정도 걸리고, 이후에 다시 열 때는 20초 정도 걸린다. }나 ;를 넣을 때, 자동으로 formatting이 되지 않는다. 설정을 다 찾아서 수정해도 안 된다… 그래서 자동 fomatting은 Visual Studio 기능을 사용하고 있다. 최근에 업데이트 하고나서 팅기는 경우가 가끔 발생한다. Visual Studio 문제일 수도 있으나, 보통 code completion 리스트가 뜰 때 팅기는 것으로 봐서 ReSharper 문제같다. 사람들이 왜 이런 플러그인들을 쓰는지 처음에는 잘 몰랐다. Visual Studio 기능만 해도 충분한 것 같은데 굳이 유로 플러그인들을 써야 하나…? 하는 생각이었다. 하지만 실제로 써보니까 그 이유를 알 것 같다. 무엇보다 네비게이션이나 코드 분석이 빨라서 좋았다. 아주 만족스럽게 사용하고 있다.\n","description":"","tags":[],"title":"ReSharperC++ 사용 후기","uri":"/posts/2021/resharpercpp-review/"},{"categories":["Algorithm","Codeforces","Contests"],"content":"\nCodeforces Round #706 (Div. 2)에 참가했다. 다행히 D까지 풀어서 괜찮은 결과가 나온 것 같다. E는 뭐 어떻게 해야할지 몰랐는데, 나중에 다른 사람의 풀이를 보니까 생각보다 쉬운 문제였다.\n전체 Code\nA. Split it! 앞뒤로 펠린드롬이어야 하는데, 각 조각의 크기를 1개로 해야 앞/뒤 길이가 최소가 되고, 그래야 맞을 가능성이 높아진다. 그래서 앞/뒤로 펠린드롬 길이를 구하고, 이 길이가 k보다 크면 YES, 작으면 NO이다. 여기서 같을 경우가 문제가 되는데, a_k + 1이 있기 때문에 k로 가득 차는 경우(k*2 == n)에는 NO, 아니면 YES를 하면 된다.\nB. Max and Mex 몇몇 케이스들을 만들어서 손으로 풀어보면, 경우의 수가 몇 가지 없다는 것을 알 수 가 있다.\n모든 수가 있는 경우 (0, 1, 2, …)\n이 경우에는 mex는 max+1이 되는데, 추가되는 값은 max+1이 된다. 즉, 셋에 최대값이 하나 늘어나고, 다시 1번 경우처럼 된다.\nmex와 max의 차이가 1인 경우 (0, 1, 2, 4)\n이 경우 추가되는 값은 4로, 즉 max값이다. 즉 그대로(2번 경우) 된다.\nmex와 max의 차이가 2이상인 경우 (0, 1, 2, 7)\n이 경우 추가되는 값은 5 ((3+7)/2 = 5)로, mex값보다 크고, max값보다 작다. 즉, 3번 경우처럼 된다.\n1번 경우는 연산을 할 때마다 하나씩 늘어나므로 n+k, 2번 경우는 안 바뀌므로 n, 3번 경우는 추가되는 값이 원래 배열에 있으면 n, 없으면 n+1로 하면 된다(k \u003e 0인 경우에만).\nC. Diamond Miner 일단 miner와 mine의 위치를 따로 저장하고, 각각 가장 큰 값 끼리 연결하면 합산한 값은 가장 작은 값이 된다. 왜냐하면, 결국 miner거리^2 + mine거리^2의 제곱근인데, 제곱근은 값이 증가할수록 증가폭이 적어지기 때문에 한 번 제곱근으로 묶을 때 가장 큰 값을 묶어야 효율이 좋기 때문이다.\n뭔가 애매하게 넘어갔는데 아마 Editorial에 내용 증명이 있지 않을까…\nD. Let’s Go Hiking 상당히 흥미롭고, 어려운 문제였다. 게임이론이라 처음에는 DP인 줄 알았다.\n일단 산봉우리(극댓값)에 있어야 가능성이 있다는 것을 알 수 있다. 경사진 곳에 있으면 바로 근처 아래에 둬서 못 움직이게 할 것이고, 극솟값은 어차피 움직일 수가 없기 때문이다.\n이제 산봉우리에서 양옆으로 경사의 길이가 어느정도인지 알아봐야 하는데, 여러 경우들을 살펴보면 결국 양옆 경사 길이가 같고 산봉우리포함 경사의 길이가 홀수인 경우만 가능하다는 점을 알 수 있다.\n만약 짝수 길이인 경우\n상대방이 맨 끝에 자리잡으면 무조건 지게 된다. 왼쪽으로 가면 만나게 되고, 오른쪽으로 가면 내가 먼저 끝에 도달하기 때문이다.\n양옆 길이가 다른 경우\n상대방이 긴 쪽으로 짝수 길이가 되게 자리잡으면 위의 경우가 되서 무조건 지게 된다.\n홀수 길이인 경우\n상대방이 맨 끝에 자리잡으면 그쪽 방향으로 가서 이기면 되고, 초록색처럼 짝수 길이에 자리잡으면 반대편으로 가면 이길 수 있다.\n여기에 추가로 만족하는 경사 길이보다 크거나 같은 경사가 다른 곳에 있으면 안 된다. 상대방이 다른 경사를 타고 올라가는 경우가 있기 때문이다.\n위의 경우를 찾는 방법은 여러가지가 있을 것 같은데, 본인은\nd[i - 1] \u003c d[i] \u0026\u0026 d[i] \u003e d[i + 1]인 위치를 찾고, 양 옆 경사의 길이를 구한다. 양 옆 경사의 길이가 같고 홀수인 경우, 최대 경사 길이가 갱신이 된다면 res = 1하고 경사 길이 갱신 최대 경사 길이가 같으면 res = 0 위의 조건이 아닌데 최대 경사 길이가 갱신되거나 같으면 res = 0 마지막에 맨 왼쪽-\u003e오른쪽 내려가는 경사, 맨 오른쪽-\u003e왼쪽 내려가는 경사도 체크해 최대 경사 길이보다 크거나 같으면 res = 0 이렇게 구현했다.\nE. Garden of the Sun Contest 도중에는 풀지 못했다. 일단 맨 윗줄을 다 칠하고, 꽃이 있는 열만 세로로 칠하는데 연속해서 나오는 경우 한 칸 건너뛰고 칠하고 이런 방식으로 접근했다. 이러니까 사이클이 생기는 경우가 생겨서 적절히 지워줘야 하는데 풀지 못했다. 나중에 다른 사람들이 푼 것을 보니 너무 쉽게 풀어서 놀랐다.\n문제 특성상 여러 풀이가 있을 수 있지만, 공통적으로 3의 배수를 기준으로 문제를 푸는 것 같다.\n일단 3의 배수 기준으로 세로로 쭉 칠한다. 0, 2, 5, 8열… 이렇게 칠한다. 이러면 기존에 있는 꽃들은 모두 세로줄에 포함되게 된다. 이제 이 세로줄들을 연결하면 되는데, 각 세로줄 사이에 꽃이 1개 있으면 그 꽃을 기준으로 연결하고, 없으면 그냥 맨 위에 연결하면 된다.\n이렇게 풀면 한가지 예외 케이스가 있는데, 세로줄을 칠하기 직전에 정원 너비가 끝나는 경우, 가장 오른쪽에 있는 꽃들은 세로줄에 연결이 안 되게 된다 (오른쪽 세로줄에 연결해야 하는데, 만들기 전에 정원 너비가 끝나기 때문). 이 경우만 해당 꽃들을 왼쪽 세로줄에 연결하면 된다.\n적절히 칠하고 사이클이 생기는 경우를 제거하는 방향으로 생각하니까 너무 복잡해서 풀 수가 없었다. 생각한 풀이가 너무 어려운 경우 완전히 새로 생각하는 법도 고려해야 겠다.\n","description":"","tags":[],"title":"Codeforces Round #706 (Div. 2)","uri":"/posts/2021/codeforces-round-706-div2/"},{"categories":["Algorithm","Codeforces","Contests"],"content":"\nCodeforces Round #705 (Div. 2)에 참가했다. C에서 좀 삽질을 해서 만족스럽진 않다. C 고민 -\u003e D 고민 -\u003e C 고민 이렇게 왔다갔다 하니까 오히려 더 망하는 것 같다. 그래도 전에 레이팅을 많이 떨어뜨려놔서 조금은 오를 것 같다.\n전체 Code\nA. Anti-knapsack 처음에 문제가 무슨 소리인지 이해가 가지 않아서 조금 시간이 걸린 문제이다.\n일단은 k보다 큰 수들은 어떤 것을 더해도 k보다 크기때문에 답으로 넣어준다. 그리고 남은 것들이 중요한데, 그냠 남은 것들의 뒤에 절반만 넣어주면 된다. 그래야 반대편이랑 매칭이 안 되기 때문이다. 예를 들어 k가 7인 경우 1, 2, 3은 빼고 4, 5, 6은 넣고 이런식으로.\nB. Planet Lapituletti 일단 뒤집었을 때도 유효한 숫자는 0, 1, 2, 5, 8밖에 없다는 것을 알 수 있다. 여기서 2 \u003c-\u003e 5이고 나머지는 그대로 유지된다.\n자리수가 모두 2자리이기 때문에, 분에 1씩 더해가면서 뒤집었을 때 유효한지 체크하면 된다. 뒤집을 떄 분/초가 서로 바뀌고 2는 5로, 5는 2로 바뀌고, 한 자리수는 두 자리수(8이면 80)가 된다는 점에 주의해야 한다.\nC. K-beautiful Strings 기존의 string보다 커야하기 때문에, 뒤에서부터 바꿔보자. 현재 위치를 i라 할 때, str[i]에 있는 알파벳보다 큰 알파벳을 넣으면, i + 1부터 맨 뒤까지 자리에는 아무 알파벳이나 들어가도 된다. 이제 이 남은 자리에 a부터 k로 나눠지지 않아 부족한 알파벳을 채우고, 남은 자리는 전부 a로 채우면 된다. 이것을 뒤에서부터 하면 된다. 알파벳의 숫자는 num[x]로 관리하면 된다.\n여기서 주의할 점은 알파벳을 채우는 과정을 바로 하는 것이 아니라 가능한 지 확인 후 가능한 경우에만 최종적으로 채워야 한다. 이것 때문에 TLE를 한 번 받았다…\nD. GCD of and Array 아이디어는 간단하다. 각 자리의 수마다 소인수분해를 하고, 소수들이 모든 자리에 1이상 있는 경우 결과에 해당 소수 * 해당 소수에서 가장 적은 수를 곱해준다. 그리고 쿼리가 들어올 때, 쿼리 값을 소인수분해하고 쿼리 자리에 소수들을 곱해서 해당 소수의 최소 개수가 갱신되는 경우 그만큼 곱해주면 된다.\n하지만 문제는 n이 20만이기 때문에 어떻게 소수의 최소 개수를 관리할지가 문제다. 구간의 최소값이기 때문에 세그트리도 생각해봤는데 메모리가 부족할 것 같고, map도 시간이나 메모리가 부족할 것 같았다. 하지만 업솔빙을 해보니 map으로도 풀리더라…\nmap을 map[소수] = { 인덱스, 개수 }로 정의하고, map[소수].size()가 n이 되면 해당 소수의 최소 개수가 갱신된 것이기 때문에 map[소수]를 돌면서 최소 개수만큼 개수를 빼주고, 개수가 0인 것은 제거해준다. 그리고 결과값에 최소 개수 * 소수를 곱해주면 된다.\n","description":"","tags":[],"title":"Codeforces Round #705 (Div. 2)","uri":"/posts/2021/codeforces-round-705-div2/"},{"categories":["Algorithm","Codeforces","Contests"],"content":"\n어제 Educational Codeforces Round 105 (Rated for Div. 2)에 참가했다. 근데 풀다가 머리가 너무 아파서 도중에 포기한 라운드다… 이미 제출은 해서 점수가 폭풍같이 떨어질 예정이다.\n전체 Code\nA. ABC String 알파벳이 3개밖에 없기 때문에, 각 알파벳에 ( 또는 )를 넣는 모든 경우를 구하고, 각 경우의 수마다 괄호의 짝이 맞는지 확인하면 된다.\n그냥 심플하게 4중 for문 돌렸다.\nB. Berland Crossword 모서리 부분만 잘 처리하면 된다. 왜냐하면 모서리 부분을 제외하고는 각 면들이 서로 영향을 안 주기 때문이다.\n처음에는 모서리를 먼저 지우고, 남은 숫자들을 가지고 판단했는데, 이러면 여러 예외들이 생긴다. 그래서 나중에 업솔빙때 모서리를 칠하는 모든 경우를 구하고 그 상태에서 남은 숫자들을 가지고 판단하니 맞았다. 판단 방법은, 먼저 모서리를 칠한 부분에 해당하는 면 숫자를 빼주고, 남은 숫자가 0보다 작거나, n - 2보다 큰 면이 있으면 false, 없으면 true로 판단하면 된다.\nC. 1D Sokoban 생각보다 구현이 까다로운 문제였다.\n일단 0에서 시작하기 때문에 양수 부분과 음수 부분으로 나누고, 음수 부분은 뒤집에서 계산할 수 있다. 이제 박스들을 움직여서 special position들에 둘 수 있는지 확인해야 한다. 여러 방법이 있겠지만, 여기서는 투 포인터를 이용했다. special position들을 담은 배열을 b[]라고 할 때, 투 포인터 영역을 해당 영역 special position들에 박스들을 전부 둘 수 있는 경우로 한다. 이 경우가 가능한지 판단하면 되는데, b[r]보다 작거나 같은 박스 위치를 구하고, 해당 박스부터 그 이전 박스들까지의 개수가 오른쪽 special position과 왼쪽 special position의 길이(r - l + 1)보다 크거나 같으면, 해당 영역에 있는 모든 special position들을 채울 수 있다. special position 개수 + b[r]이후로 채워진 special position 개수를 더해주면 된다. 후자는 미리 prefix sum으로 구해두면 된다.\nD번은 아직 못 풀었는데, 나중에 시간나면 풀어볼까 생각중이다.\n","description":"","tags":[],"title":"Educational Codeforces Round 105 (Rated for Div. 2)","uri":"/posts/2021/edu-codeforce-round-105-div2/"},{"categories":["Programming","Etc"],"content":"최근 톡방을 보다가 underflow라는 단어가 나왔다. 정수가 음수 범위를 넘어갈 때 underflow라고 설명하던데, 이게 잘못된 말이다고는 알고 있었다. 하지만 underflow가 막연히 정수에는 없고 실수에만 있는 개념이다는 것만 알고, 정확히 뭔지는 잘 몰랐다. 그래서 찾아봤다.\nUnderflow in float Underflow를 설명하기 전에, 먼저 float (floating point, 부동 소수점)가 컴퓨터에서 어떻게 표현되는지 알아야 한다. 실수 값을 표현할 때는 부호 * 지수 * 가수로 나누고, 이 3부분을 일정 비트 할당해서 표현한다. 예를 들어 32bit float의 경우 부호에 1bit, 지수에 8bits, 가수에 23bits를 할당해서 표현한다. 그렇기 때문에 실수의 모든 값을 표현할 수 없고 지수+가수에 의해 정의된 간격 근처로만 표현 가능하다. (흔히 말하는 소수점 오차가 이 이유 때문에 발생한다.)\nUnderflow라고 하면 보통 arithmetic underflow를 말하는데, 위키피디아에 있는 정의는\nThe term arithmetic underflow (also floating point underflow, or just underflow) is a condition in a computer program where the result of a calculation is a number of smaller absolute value than the computer can actually represent in memory on its central processing unit (CPU).\n즉, 계산의 절대값이 표현할 수 있는 가장 작은 값보다 작을 때 발생한다고 적혀있다.\n예를 들어 지수의 최소값이 -98이고 가수가 3자리로 정의되어있다고 하자. 이때 x = 6.87 * 10^-97, y = 6.81 * 10^-97라는 수들은 위의 정의에 만족하는 수들이다. 하지만 이상한 특징이 있는데, x != y인데 x - y = 0이 된다는 점이다. 이는 x - y = 0.06 * 10^-97 = 6.00 * 10^-99라서 정규화 된 수로 표현하기에는 너무 작아서 0이 되어버리기 때문이다. 이 현상을 Underflow라고 부른다.\n이 현상을 완화하기 위해 IEEE 754에서는 만약 지수의 값이 최소값이면, 가수는 정규화를 하지 않고 그대로 두는 예외를 추가했다. 이를 비정규화된 수(Denormalized numbers) 라고 부른다. 즉, 위의 값도 6.00 * 10^-99으로 정규화하지 않고 0.60 * 10^-98 그대로 두는 것이다. 이럴 경우 정규화된 수보다 더 작은 수들도 표현할 수 있어서 underflow현상을 어느정도 막아줄 수 있다. 이러한 동작을 점진적 underflow(Gradual underflow) 라고 부른다.\nUnderflow in integer? 하지만 이러한 현상은 정수에서는 발생하지 않는다. 일반적으로 8bit 정수인 경우, 127에서 1을 더해 -128이 되는 것을 overflow, -128에 1을 빼면 127이 되는 것을 underflow라고 말하는 경우가 많지만, 후자의 경우도 overflow라고 말해야 한다. 둘다 표현할 수 있는 수 범위를 넘어가는 경우이기 때문이다. 실제로 CPU안에 있는 overflow flag에서도 두 경우 다 1로 set된다.\nan integer overflow occurs when an arithmetic operation attempts to create a numeric value that is outside of the range that can be represented with a given number of digits – either higher than the maximum or lower than the minimum representable value.\nWikipedia에서도 integer overflow의 정의를 큰쪽/작은쪽 둘 다 포함한다고 적혀있다. 따라서 integer underflow라는 말은 잘못된 말이고, 두 경우 다 overflow라고 불러야 맞다.\n하지만 검색해보면 수많은 곳에서 위와 같은 현상을 underflow라고 말하는 걸 발견할 수 있다. 의미야 통하겠지만, 그래도 단어의 정의들은 정확하게 아는 것이 좋지 않을까…\n참고한 사이트 Arithmetic underflow - Wikipedia\nInteger overflow - Wikipedia\n모든 컴퓨터 과학자가 알아야 할 부동 소수섬의 모든 것(What Every Computer Scientists Should Know About Floating Point Arithmetic)\nUnsigned integer underflow in C - Stack Overflow\n","description":"","tags":[],"title":"Integer underflow는 잘못된 말이다","uri":"/posts/2021/integer-underflow-is-a-wrong-sentence/"},{"categories":["Algorithm","Codeforces","Contests"],"content":"\n오늘 Codeforces Round #704 (Div. 2)에 참가했다. 난이도는 평소보다 쉽게 나온 것 같다. 이번에는 그래도 괜찮게 푼 것 같다. D번까지 푸니까 힘이 다 빠져서 E번은 대충 생각하고 넘어갔는데, 지금 생각해보면 후반에도 집중했으면 풀었을 것 같다는 생각이 든다.\n글쓰는 도중에 D번에서 System test fail이 떳다. 망할 전체 Code\nA. Three swimmers p초일 때 세 선수가 왼쪽 끝까지 얼마나 남았는가만 계산해서 풀면 된다. 왕복하는데 시간을 x초라고 하면, p % x를 하면 가장 마지막으로 왼쪽 끝을 찍고 몇 초가 흘렀는지 알 수 가 있다. 이것을 x - (p % a)처럼 x에 대해 빼주면 남은 시간을 알 수 있다. 다만 p % x가 0인경우는 현재 왼쪽 끝에 있는 경우인데, 이 경우에만 0으로 바꿔주면 된다.\nB. Card Deck 문제 설명과 test case들을 봤을 때, 덱에 남아있는 카드 중 가장 큰 카드를 기준으로 뽑아내면 무조건 최대가 된다는 점을 파악할 수 있다. 왜냐하면 맨 처음에 뽑은 카드는 n^n-1를 곱하는데, 이 값이 다른 값을을 압도?하기 때문이다. 자세한 증명은 Editorial에서…\n가장 큰 카드의 위치를 기준으로 뽑을 때, 무식하게 그냥 덱을 순환해서 최대값 찾고 이러면 시간초과가 날 수도 있다. 방법은 여러가지가 있을 것 같은데 필자가 푼 방식은, 먼저 x번 카드가 덱에 있으면 1인 idx[x] 배열을 만들고, 덱에서 빠져나가면 idx[x]를 0으로 만들어준다. 그리고 현제 최대값에서 가장 가까운 최대값을 idx배열을 이용해서 찾으면 된다.\nC. Maximum width 문자열을 s1, s2라고 하면, s2를 왼쪽으로 최대한 몰아넣은 뒤, 맨 뒤 글자부터 하나씩 오른쪽으로 붙이면서 최대값을 구하면 된다.\n최대한 오른쪽으로 붙일 때 어느 위치에 붙여야 하는지 알아야 하는데, 이는 prefix sum이랑 비슷한? 개념을 가진 전처리 배열을 만들면 된다. last[x][y]를 x길이만큼 있을 때 y번째 알파벳이 가장 마지막에 있는 위치로 정의하고, 미리 값들을 채워넣는다. 그리고 오른쪽으로 붙일 때는, 직전에 붙인 자리를 i라 했을 때 last[i-1][y]에다가 붙이면 된다.\nD. Genius’s Gambit 쓰는 도중 System test fail이 나긴 했는데… 일단 내 풀이를 적어본다. (다행히 풀이는 맞았다)\n일단 1들을 전부 왼쪽으로 밀고, 나머지는 0을 오른쪽에 넣어둔다. 이제 가장 오른쪽에 있는 1을 한 칸씩 옮기면 1의 개수가 늘어나게 된다. 이렇게 끝까지 밀어보고, 부족하면 그다음 오른쪽에 있는 1을 한 칸 옮기면 역시 1의 개수가 1개 늘어난다. 여기서 한 칸 더 옮기면 오히려 줄어들게 되니까 그다음 오른쪽에 있는 1을 한 칸 옮긴다. 그러다가 맨 왼쪽 1도 옮기는 경우가 생기면 No를 출력한다.\n여기서 1이 1개인 경우만 예외처리를 해서 pretest는 통과를 했는데… 좀 더 생각해봐야 겠다.\n다시보니까 풀이는 맞는데, 코드에서 0이 없고 1만 있는 경우(111111)인 경우 오류가 있었다. 1이 한 개만 있는 경우는 체크했는데 저 경우는 체크를 못 했다. 이런 코너케이스들을 꼼꼼히 체크했어야 했는데…\nE. Almost Fault-Tolerant Database 풀이를 보니 그냥 백트래킹이다. 생각은 해보긴 했는데 시간초과 날 것 같아서 넘겼던 건데…\n먼저 첫 번째 배열을 기준으로 다른 배열들을 전부 검사한다. 만약 다른 모든 배열의 차이가 2 이하라면 바로 첫 번째 배열로 출력하면 되고, 한 개라도 5 이상이라면 No를 출력한다. 그러면 이제 첫 번째 배열하고 3~4개 차이가 나는 배열만 남게 된다. 이 배열들이 만족하도록 첫 번째 배열을 바꾸면 되는데, 3개 차이는 1개, 4개 차이는 2개를 바꾸면 되니 각각 경우의 수가 3개, 6개가 생긴다. 이 경우의 수를 모든 3~4개 차이가 나는 배열에 대해서 백트래킹을 해 모든 경우를 구하고, 모든 배열을 만족하는 경우가 있으면 출력, 없으면 No를 출력하면 된다.\n여기서 그냥 하니까 시간초과가 나서 백트래킹 함수에 remain 파라미터를 넣어서 첫 번째 배열이 최대 2개까지만 바뀌도록 하니까 통과했다.\n","description":"","tags":[],"title":"Codeforces Round #704 (Div. 2)","uri":"/posts/2021/codeforce-round-704-div2/"},{"categories":["Algorithm","Codeforces","Contests"],"content":"PS + 그래픽스 공부를 하려고 한 학기 휴학을 했는데, 집에서만 하다보니까 생각보다 공부할 의욕이 나질 않았다. 그래서 앞으로 공부한 것을 블로그에 꾸준히 기록하면서 동기부여와 성취감을 주기로 했다. 그 중 하나로 CodeForeces Contest 나간 것을 정리하려고 한다.\n어제 Codeforces Round #703 (Div. 2)에 참가했다. C번에 interactive 문제가 있었는데, 아직 interactive에 익숙하기 않아서 푸는데 시간이 조금 걸렸다. 그리고 B번도 접근을 잘못해서 조금 시간이 걸렸다.\nD번에 남은 모든 시간을 쏟고 결국 못 풀었는데, 그냥 C1 문제 조금 수정해서 C2나 풀걸 그랬다…\nCode\nA. Shifting Stacks 돌을 오른쪽으로 옮길 수 있기 때문에 최소한의 돌을 써서 조건을 만족하려면 0, 1, 2, 3, ... 이런 순서로 돌을 배치하면 된다. 남은 돌들은 마지막에 몰아넣으면 된다.\n그러면 앞에서부터 돌의 개수를 누적해 더하면서 이게 0, 1, 2, 3, ...의 누적합보다 작아지는 경우는 이 순서로 배치할 수 없으므로 NO, 다 가능하면 YES를 출력하면 된다.\nB. Eastern Exhibition 거리를 x좌표의 차이 + y좌표의 차이로 계산하기 때문에, x와 y를 분리해서 접근해보자.\n그러면 x좌표들의 중간 지점을 잡으면 x좌표 거리의 합이 최소가 된다. 만약 개수가 홀수인 경우 딱 중심에 있는 집에 둬야하고, 짝수인 경우 그 사이에 두면 된다. 이렇게 x좌표 기준으로 가능한 경우의 수를 구할 수 있다.\n이걸 똑같이 y좌표에도 적용하고 x좌표 기준 경우의 수 * y좌표 기준 경우의 수를 하면 된다.\n처음에는 중복되는 좌표를 빼고 생각을 했는데, 중복되어도 상관이 없다는 것을 나중에 깨달았다…\nC1. Guessing the Greatest (easy version) 최근에도 컨셉이 비슷한 interactive문제가 있어서 이분탐색으로 접근했다.\n일단 전체를 쿼리를 날려서 2번째로 큰 수 위치(2idx)를 구한다. 그리고 이분탐색을 돌린다.\n왼쪽 절반 / 오른쪽 절반 각각 쿼리를 날려서 각각 범위의 2idx를 구하고, 이게 전체 범위의 2idx하고 같으면 해당 구간에 가장 큰 수가 있으므로 해당 구간으로 줄여서 위 과정을 반복하면 된다.\n그러다가 크기가 2나 3으로 줄어들게 되는데,\n2인 경우: 2idx가 아닌 위치가 답\n3인 경우\n2idx가 마지막에 위치해 있으면 가장 큰 수가 앞에 1~2구간에 있으므로 해당 구간을 쿼리를 날리고 2인 경우를 적용하면 된다. 2idx가 1~2구간에 위치해 있으면 가장 큰 수가 3구간이 있을 수도 있는데, 이는 1~2구간에 쿼리를 날려서 2idx값이 바뀌면 가장 큰 수가 3구간에 있는거고, 아니면 1~2구간이 있으므로 2인 경우 적용. 이러면 이분탐색 한 번에 2번의 쿼리를 날리기 때문에 2*log2(100000) = 33.21...로 C1을 풀 수 가 있다. 하지만 C2는 쿼리 제한이 20으로 위 방식으로는 풀 수 가 없다.\nC2. Guessing the Greatest (hard version) C1을 풀고나서 C2는 그냥 넣어봤는데 당연히 쿼리 개수를 넘어가니까 틀렸다. 전략을 수정해야 할 것 같아서 그냥 바로 D로 넘어갔다.\nUpsolving을 해보니, 핵심적인 부분은 처음 구한 2idx를 계속 이용하는 것이다. 2idx를 구하고 [1, 2idx] 범위로 쿼리를 날린 결과가 2idx랑 같으면 해당 범위에 가장 큰 수가 있고, 없으면 [2idx, n] 범위에 있게 된다.\n이제 이 범위에서 가장 큰 수를 찾으면 되는데, 왼쪽 범위와 오른쪽 범위 처리 방식이 약간 다르다.\n오른쪽 범위인 경우, 해당 범위의 중간값 위치를 midx라 할 때, [2idx, midx]를 해서 2idx랑 midx랑 같으면 범위의 왼쪽 절반에 가장 큰 수가 있는 것이고, 오른쪽 절반에 있게 된다.\n왼쪽 범위인 경우 이 개념을 뒤집어서 ( [midx, 2idx] ) 생각하면 된다. 이렇게 하면 쿼리를 절반으로 줄일 수 있게 된다.\n이분탐색이 생각보다 까다로운게 설계를 잘못하면 개수가 1~3개 남은 마지막 케이스에서 꼭 틀리는 경우가 나온다. Upsolving 할 때도 마지막 케이스때문에 조금 시간이 걸렸다. 이분탐색 문제를 몇 개 더 따로 풀어봐야겠다.\nD. Max Median Contest때는 투포인터 + running median으로 양쪽 끝중에 더 작은 값을 빼는 방식으로 접근했는데 계속 WA가 나왔다. 아마 풀이가 틀렸다고 생각하고 다른 방법을 생각하다가 결국 못 풀었는데 나중에 Editorial을 보니까 문제를 결정문제로 바꿔서 풀어버리더라… parametric serach는 심심하면 나오는데 알아차리기가 힘든 것 같다.\n일단 이 문제는 parametric search로 생각을 해야 한다. 어떤 값 x를 잡고 어떤 subarray의 중앙값이 이 x보다 크거나 같으면 x값을 늘리고, 아니면 줄이는 방식으로 접근해야 한다.\n이러면 위의 조건을 판별하는 방법은, 먼저 새로운 배열을 하나 만들어서 x보다 크거나 같으면 1, 작으면 -1로 바꿔서 넣는다. 이러면 위의 조건은 subarray의 합이 0보다 크면 조건을 만족한다는 것을 알 수가 있다. (0보다 커지는 경우면 1의 개수가 더 많은 경우인데, 이러면 당연히 1이 중앙값에 위치하게 되고, 이는 중앙값이 x보다 크거나 같다는 것을 의미한다.) 이것을 prefix sum을 이용해 subarray의 최대값을 구하고 이게 0보다 큰지 검사하면 된다.\nprefix sum을 이용해 구하는 방법은 반복문을 돌면서 sum[i-k] 이 최소값인지 확인 후 갱신하고(이러면 [0, i-k] 구간의 최소값이 됨), 이 값이 sum[i] - 최소값이 i에서 끝나는 subarray의 최대값이 된다.\nparametric search는 개념은 쉬운데 문제로 나오면 꽁꽁 숨겨져서 나와서 알아차리기가 어렵다. 결정 문제로 바꾸면 확인하는 조건이 쉬워진다는 점을 빨리 알아내야 하는데… 쉽지 않다.\nE. Paired Payment E가 더 쉬웠다는 말이 좀 있던데, Upsolving해보니 둘 다 비슷한 난이도인 것 같다. 역시 이것도 특정한 방법을 알지 못하면 풀기 힘든 문제였다.\n일단 먼저 생각할 수 있는 것은, 2번 가는 경로로 그래프를 다시 만들어서 다익스트라를 돌리는 것인데 이러면 시간과 메모리가 초과하게 된다.(최악의 경우 각 정점에 모든 간선이 생겨서 간선 개수가 n^2이 된다.) 그래서 문제를 자세히 읽어보면 길의 비용이 50으로 아주 작은 것을 알 수가 있는데, 그러면 BOJ 1533 - 길의 개수이 문제와 비슷한 테크닉을 이용할 수 있다.\n먼저 각 정점마다 추가로 50개의 새로운 정점을 만든다. 편의를 위해 각 정점의 번호 * 51을 해서 확보하자. 이 정점들은 A라는 곳으로 가는 경로가 있을 때 A + cost 로 중간에 거쳐가는 정점이라고 생각하면 된다. a, b, cost인 간선을 읽으면, 먼저 a-\u003e[b의 중간지점]으로 가는 간선은 (a * 51 -\u003e b * 51 + cost)이고 비용이 0인 간선을 추가한다. 비용이 0인데, 이는 나중에 중간지점 -\u003e 다른정점으로 갈 때 함께 계산한다. 그리고 [b의 중간지점들] -\u003e a로 가는 간선인 (b * 51 + i -\u003e a * 51)를 추가한다. 비용은 (cost + i)^2으로 계산하면 된다.\n간선의 비용을 추가 정점으로 계산한다고 생각하면 된다. 이제 이 그래프를 다익스트라를 돌려서 풀면 된다. 이러면 간선의 개수가 e * 51로 확 줄면서 시간 내에 나올 수 있게 된다.\n","description":"","tags":[],"title":"Codeforces Round #703 (Div. 2)","uri":"/posts/2021/codeforce-round-703-div2/"},{"categories":["Algorithm","SCPC"],"content":"오늘(2020-09-05) 오후 9시에 SCPC 2020 Round 2가 끝났다.\n보다시피 망했다… 1, 2번은 어찌저찌 풀었는데, 3번이 Test case 2까지만 맞고 계속 TLE가 나서 별 짓을 다해보다가 포기.\n4번은 세로선을 범위 정해서 어찌저찌하면 되지 않을까…? 생각하다가 너무 복잡해져서 포기.\n5번은 문제가 괴랄한데 Test case 1 조건만 보니까 쉬워서 그것만 맞췄다.\n1. 실력 맞추기 서로 짝을 지어서 실력의 차이의 합을 최소로 만드는 것은 두 배열을 정렬하고 각각 맞추면 최소가 된다.\n그런데 문제는 A그룹의 사람을 바꿀 수 있다는 점이다. 이때 바꾸는 경우로는 A그룹의 누군가(A[i])를 B그룹의 누군가(B[i])와 같게 만들어서 서로 소멸하는 방법을 생각할 수가 있다.\n그러면 둘 사이에 있는 연속한 숫자들은 한 칸씩 앞으로 당겨지게 된다. 이 경우에는 앞에 숫자가 지워지면서 해당 숫자의 차이는 사라지게 되고, 뒤의 숫자들이 당겨지면서 서로간의 차이들이 변하게 된다. 이렇게 변하는 실력의 차이를 최대로 하는 경우가 정답이 된다.\n0 1 2 3 4 5 aGap x 0 5 1 1 1 bGap x -2 -1 -2 -1 -2 aGap과 bGap은 해당하는 위치가 앞으로 한 칸 당겨졌을 때 실력의 차이가 얼마나 변경되는지 기록하는 배열이다. 더 좋아질수록(실력의 차이가 줄어들수록) 양수의 값을 가진다.\n이제 (이 배열의 구간합 + 구간 앞 요소의 실력 차이)의 최대값을 DP를 이용해 풀면 된다.\ndp[i] = i번째로 끝나는 구간 중 최대값 일 때\ndp[i] = max(aGap[i] + abs(a[i-1] - b[i-1]), aGap[i] + dp[i-1])\n-\u003e i위치에서 앞에 구간에서 이어가는 것과 새로운 구간으로 시작하는 것 중 더 큰 것을 선택하면 된다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #define _CRT_SECURE_NO_WARNINGS 1 #include \u003ciostream\u003e #include \u003ccstdio\u003e #include \u003cutility\u003e #include \u003ccstdlib\u003e #include \u003calgorithm\u003e #include \u003cvector\u003e using namespace std; using lli = long long int; int tNum; int n; int a[200001], b[200001]; lli aGap[200001], bGap[200001]; lli dp[200001]; lli gap; int main(void) { // freopen(\"input.txt\", \"r\", stdin); ios_base::sync_with_stdio(false); cin.tie(NULL); cin \u003e\u003e tNum; for(int tt = 1; tt \u003c= tNum; tt++) { gap = 0; cin \u003e\u003e n; for(int i = 0; i \u003c n; i++) { cin \u003e\u003e a[i]; } for(int i = 0; i \u003c n; i++) { cin \u003e\u003e b[i]; } sort(a, a + n); sort(b, b + n); for(int i = 1; i \u003c n; i++) { lli re = (lli)abs(a[i] - b[i - 1]); aGap[i] = (lli)abs(a[i] - b[i]) - re; re = (lli)abs(b[i] - a[i - 1]); bGap[i] = (lli)abs(b[i] - a[i]) - re; } for(int i = 1; i \u003c n; i++) { dp[i] = aGap[i] + (lli)abs(a[i - 1] - b[i - 1]); if(dp[i] \u003c dp[i - 1] + aGap[i]) dp[i] = dp[i - 1] + aGap[i]; if(gap \u003c dp[i]) gap = dp[i]; } for(int i = 1; i \u003c n; i++) { dp[i] = bGap[i] + (lli)abs(a[i - 1] - b[i - 1]); if(dp[i] \u003c dp[i - 1] + bGap[i]) dp[i] = dp[i - 1] + bGap[i]; if(gap \u003c dp[i]) gap = dp[i]; } lli res = 0; for(int i = 0; i \u003c n; i++) { res += (lli)abs(a[i] - b[i]); } cout \u003c\u003c \"Case #\" \u003c\u003c tt \u003c\u003c \"\\n\"; cout \u003c\u003c res - gap; cout \u003c\u003c endl; } return 0; } 2. 고구마 문제가 조금 이상한 것 같다… 풀이대로라면 썩은 고구마면 오히려 판매자가 돈을 더 주는 경우가 되는데… 아무튼 문제는 구간합인데 k를 넘지 않는 최대 구간합을 구하면 된다.\n단순하게 접근한다면 위 문제와 비슷하게 i번째가 마지막인 구간일 때 k를 넘지 않는 최대 구간합을 구하는 방법을 생각할 수 있다. 문제는 k를 넘지 않는 이라는 조건 때문에 위 문제처럼 단순 비교로는 안 되고, 구간의 앞을 잘라가면서 확인을 해야 하는데 이러면 O(n^2)라서 무조건 시간초과다. (n \u003c= 300000)\n그렇기 때문에 구간의 앞을 자르는 과정을 더 빠르게 해야 한다. 구간의 합을 k 이하로 만들기 위해서는 자를 구간의 합이 현재 구간의 합 - k보다 크거나 같은 값이어야 한다. 이 값을 req라고 하자. 그리고 앞을 자르지 않은 구간의 합들을 현재 지점까지 저장해둔다. 이제 저장된 구간합 중에 req보다 크거나 같으면서 가장 근접한 구간합으로 자르면 최적의 구간합이 됨을 알 수 있다. 이것을 BST를 이용하면 구간합을 넣는데 O(logn), 값을 찾는데 O(logn)이 걸리기 때문에 최종 시간복잡도는 O(nlogn)이 된다.\nBST는 std::set과 lower_bound를 이용하면 쉽게 구현할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #define _CRT_SECURE_NO_WARNINGS 1 #include \u003ciostream\u003e #include \u003ccstdio\u003e #include \u003cutility\u003e #include \u003cset\u003e using namespace std; using lli = long long int; int tNum; int n; lli m; lli d[300001]; lli res; set\u003clli\u003e pre; int main(void) { // freopen(\"input.txt\", \"r\", stdin); ios_base::sync_with_stdio(false); cin.tie(NULL); cin \u003e\u003e tNum; for(int tt = 1; tt \u003c= tNum; tt++) { res = 0; pre.clear(); cin \u003e\u003e n \u003e\u003e m; for(int i = 0; i \u003c n; i++) { cin \u003e\u003e d[i]; } pre.insert(0); lli sum = 0; for(int i = 0; i \u003c n; i++) { sum += d[i]; auto findIter = pre.lower_bound(sum - m); if(findIter != pre.end()) { if(res \u003c sum - *findIter) { res = sum - *findIter; } } pre.insert(sum); } cout \u003c\u003c \"Case #\" \u003c\u003c tt \u003c\u003c \"\\n\"; cout \u003c\u003c res; cout \u003c\u003c endl; } return 0; } 3. 아르바이트 (Test Case 2까지) 배열에 들어가있는 숫자들이 계속 바뀌게 된다. 그래서 중간값을 기준으로 나눈 down, up BST를 만들고, 값이 변할때마다 이 down, up에 서 값들을 넣다 뺐다 하면서 균형을 맞춰준다. 이러면 O(nlogn + qklogn) (초기값 정렬 + 모든 값 갱신)이 된다.\n하지만 이래도 TLE가 난다… 끝나고 찾아보니까 set / multiset이 삽입/제거가 O(logn)이지만 상수가 좀 있어서 그러는 것 같다. priority_queue를 쓰면 된다고 하는데 나중에 다시 풀어봐겠다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 #define _CRT_SECURE_NO_WARNINGS 1 #include \u003ciostream\u003e #include \u003ccstdio\u003e #include \u003cutility\u003e #include \u003cset\u003e #include \u003calgorithm\u003e #include \u003cvector\u003e using namespace std; using lli = long long int; int tNum; int n, k, q; int d[200001]; multiset\u003cint\u003e down, up; int downNum, upNum; vector\u003cint\u003e tmp; int tSize; vector\u003cpair\u003cint, int\u003e\u003e changedNums; int res[200001]; void getChangedNum(int idx, int v) { changedNums.clear(); int st = idx - k + 1; st = max(st, 0); int sum = 0; for(int i = 0; i \u003c k; i++) { sum += d[st + i]; } changedNums.push_back({ sum, 0 }); for(int i = st; i \u003c idx; i++) { int ed = i + k; if(ed \u003e n - 1) break; sum -= d[i]; sum += d[ed]; changedNums.push_back({ sum, 0 }); } d[idx] = v; int cNum = 0; st = idx - k + 1; st = max(st, 0); sum = 0; for(int i = 0; i \u003c k; i++) { sum += d[st + i]; } changedNums[cNum++].second = sum; for(int i = st; i \u003c idx; i++) { int ed = i + k; if(ed \u003e n - 1) break; sum -= d[i]; sum += d[ed]; changedNums[cNum++].second = sum; } } void update() { for(auto ch : changedNums) { if(ch.first == ch.second) continue; auto it = down.find(ch.first); if(it != down.end()) { down.erase(it); downNum--; } else { auto it2 = up.find(ch.first); if(it2 != up.end()) { up.erase(it2); upNum--; } } if(up.empty() == true || *up.begin() \u003c ch.second) { up.insert(ch.second); upNum++; } else { down.insert(ch.second); downNum++; } if(downNum \u003e tSize / 2) { auto t = down.end(); t--; up.insert(*t); down.erase(t); upNum++; downNum--; } else if(downNum \u003c tSize / 2) { auto t = up.begin(); down.insert(*t); up.erase(t); downNum++; upNum--; } } changedNums.clear(); } int main(void) { // freopen(\"input.txt\", \"r\", stdin); ios_base::sync_with_stdio(false); cin.tie(NULL); cin \u003e\u003e tNum; for(int tt = 1; tt \u003c= tNum; tt++) { down.clear(); up.clear(); downNum = 0; upNum = 0; tmp.clear(); cin \u003e\u003e n \u003e\u003e k \u003e\u003e q; for(int i = 0; i \u003c n; i++) { cin \u003e\u003e d[i]; } int sum = 0; for(int i = 0; i \u003c k; i++) { sum += d[i]; } tmp.push_back(sum); for(int i = k; i \u003c n; i++) { sum -= d[i - k]; sum += d[i]; tmp.push_back(sum); } sort(tmp.begin(), tmp.end()); tSize = tmp.size(); for(int i = 0; i \u003c tSize / 2; i++) { down.insert(tmp[i]); downNum++; } for(int i = tSize / 2; i \u003c tSize; i++) { up.insert(tmp[i]); upNum++; } res[0] = *up.begin(); for(int i = 1; i \u003c= q; i++) { int a, b; cin \u003e\u003e a \u003e\u003e b; a--; getChangedNum(a, b); update(); res[i] = *up.begin(); } cout \u003c\u003c \"Case #\" \u003c\u003c tt \u003c\u003c \"\\n\"; for(int i = 0; i \u003c= q; i++) { cout \u003c\u003c res[i] \u003c\u003c \" \"; } cout \u003c\u003c \"\\n\"; } return 0; } 5. 삼각형의 거리 (Test Case 1까지) 5번 답게 엄청난 기하 문제이다. 그런데 Test Case 1이 ‘모든 다각형은 볼록다각형이다.’ 라는 문구가 있다.\n볼록다각형인 경우 안쪽에 삼각형들을 그려놓으면 볼록다각형을 유지하는 상태라면 어떻게든 변형해도 삼각형들의 배치는 변하지 않는다. 그러므로 좌표를 신경쓰지 말고, 몇각형인지만 신경쓰면 된다.\n곰곰히 생각해보면 위 그림처럼 가장자리를 먼저 삼각형으로 만드는 것이 좋다는 것을 알 수 있다. 이러면 가운데가 각의 수가 줄어든 다각형을 발견할 수 있고, 해당 다각형에서의 최소값만 알면 그 값 +2가 정답임을 알 수가 있다. 간단한 dp문제이다.\ndp[i] = dp[i / 2] + 2 // i가 짝수\n​ = dp[i / 2 + 1] + 2 // i가 홀수\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #define _CRT_SECURE_NO_WARNINGS 1 #include \u003ciostream\u003e #include \u003ccstdio\u003e #include \u003cutility\u003e using namespace std; using lli = long long int; int tNum; int n; int dp[301]; int main(void) { dp[4] = 1; dp[5] = 2; for(int i = 6; i \u003c= 300; i++) { if(i%2 == 0) dp[i] = dp[i / 2] + 2; else dp[i] = dp[i / 2 + 1] + 2; } // freopen(\"input.txt\", \"r\", stdin); ios_base::sync_with_stdio(false); cin.tie(NULL); cin \u003e\u003e tNum; for(int tt = 1; tt \u003c= tNum; tt++) { cin \u003e\u003e n; for(int i = 0; i \u003c n; i++) { int a, b; cin \u003e\u003e a \u003e\u003e b; } cout \u003c\u003c \"Case #\" \u003c\u003c tt \u003c\u003c \"\\n\"; cout \u003c\u003c dp[n] \u003c\u003c endl; } return 0; } 물론 다각형이 볼록다각형이 아닌 경우에는 위의 방법이 적용되지 않는다.\n이번 Round2에서는 아마 떨어질 것 같다. 아마 나랑 같은 점수대에서 갈릴 것 같은데 이러면 제출 횟수가 중요해진다. 총 제출을 13번이나 했기 때문에 힘들 것 같다. 아쉽지만 내년을 노려봐야 겠다.\n","description":"","tags":[],"title":"SCPC 2020 Round2 후기","uri":"/posts/2020/scpc-2020-round2-review/"},{"categories":["Algorithm","SCPC"],"content":"2일 전에 SCPC 2020 Round 1이 열렸다. SCPC라는 대회의 존재를 작년에 군대에 있었을 때 알았다.\n실은 PS를 중학생때까지 열심히 했는데, 고등학생이 되니까 경기도에서는 도저히 정올 예선을 뚫을 수가 없어서 포기를 했었다. 그 이후로는 따로 PS공부를 하지 않고, 대학생때 그냥 대회 있으면 참가하는 마음으로 몇몇 대회를 참가했었다. 작년 SCPC도 별 생각없이 신청을 했는데, 문제를 풀다 보니 옛날에 열심히 PS공부를 하던 것이 생각이 나고 다시 공부해볼까 하는 마음이 생겼다. 그래서 요즘 PS 공부를 조금씩 하고는 있다.\n잡설이 많았는데, 필자는 이번 대회에서 3문제 + 1문제 Case1(부분점수)을 풀었다.\n1. 다이어트 메뉴를 k개만 고를 수 있기 때문에 메뉴들을 정렬한 뒤에 k번째를 넘어가는 메뉴들은 버려도 된다.\n그리고 이제 메뉴들을 골라야 하는데, 고르는 방법은\nA식당에서 가장 큰 메뉴 + B식당에서 가장 작은 메뉴\nA식당에서 2번째로 큰 메뉴 + B식당에서 2번째로 작은 메뉴\n…\n이런식으로 합치고 합친 것중에 가장 큰 값을 출력하면 된다.\n솔직히 이렇게 풀면 맞지 않을까? 해서 작성하고 제출했는데 맞았다. 아마 증명이 있을 것 같긴 한데 잘 모르겠다…\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #define _CRT_SECURE_NO_WARNINGS 1 #include \u003ciostream\u003e #include \u003ccstdio\u003e #include \u003cutility\u003e #include \u003calgorithm\u003e using namespace std; using lli = long long int; int tNum; int n, k, a[200001], b[200001]; int main(void) { // freopen(\"input.txt\", \"r\", stdin); ios_base::sync_with_stdio(false); cin.tie(NULL); cin \u003e\u003e tNum; for(int tt = 0; tt \u003c tNum; tt++) { cin \u003e\u003e n \u003e\u003e k; for(int i = 0; i \u003c n; i++) { cin \u003e\u003e a[i]; } for(int i = 0; i \u003c n; i++) { cin \u003e\u003e b[i]; } sort(a, a + n); sort(b, b + n); lli res; lli max = 0; for(int i = 0; i \u003c k; i++) { if(max \u003c a[i] + b[k - i - 1]) { max = a[i] + b[k - i - 1]; } } res = max; cout \u003c\u003c \"Case #\" \u003c\u003c tt + 1 \u003c\u003c \"\\n\"; cout \u003c\u003c res \u003c\u003c \"\\n\"; } return 0; } 2. 카드 게임 이와 비슷한 문제를 최근에 풀어봐서 똑같이 DP로 푸니까 시간초과가 났다.\ndp[i][j]를 a[i]번째, b[j]번째 카드까지 있을 때 해당 턴 사람이 이기면 1, 지면 -1로 정의를 하고 문제를 풀었다. 여기까지는 O(N^2)이다.\n그런데 해당 턴에 이기는지 지는지를 파악하려면 카드를 1장부터 k값을 초과하지 않는 장수만큼 가져갔을 때 지는 경우(상대의 턴이니까)가 있으면 이기게 된다. 즉,\ndp[i][j] = { dp[i-1][j], dp[i-2][j], … , dp[i-xx][j], dp[i][j-1], dp[i][j-2], … , dp[i][j-yy] 중에 -1이 있으면 1 / 없으면 -1}\n(xx는 현재 상황에서 A더미에서 가져갈 수 있는 최대 개수 / yy는 현재 상황에서 B더미에서 가져갈 수 있는 최대 개수)\n이런 식이 나오게 되는데, 이 식이 최악의 경우 O(n)이기 때문에 총 시간복잡도는 O(N^3)이 되고, N이 3000까지 있기 때문에 당연히 시간초과가 나오게 된다. 그러면 저 식을 잘 처리해서 O(1)로 만들어야 하는데… 하다가 문득 생각이 떠올랐다.\n어차피 가져갈 수 있는 범위 내에서 -1이 하나라도 있는지 확인하면 되고, 범위는 카드 더미의 각 위치마다 정해져 있으니까 미리 계산이 가능하다. 그리고 -1은 해당 범위 안에 -1이 몇 개 있는지를 prefix sum을 이용하면 O(1)만에 구할 수 있다.\n아래 코드에서는 prefix sum을 2차원 배열 2개로 나누어서 풀었는데(A전용, B전용), 지금 생각해보니까 하나로 합쳐서 풀수도 있었다. 결국 이 문제처럼 2차원 배열의 부분합을 구하는 것과 같기 때문이다. 이런걸 보면 나는 아직 배워야 할 게 많다는 생각이 들었다. 이런 기초적인 것도 생각 못하다니…\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 #define _CRT_SECURE_NO_WARNINGS 1 #include \u003ciostream\u003e #include \u003ccstdio\u003e #include \u003cutility\u003e using namespace std; using lli = long long int; int tNum; int n, k; int a[3001], b[3001]; int numX[3001][3001]; int numY[3001][3001]; int rangeX[3001]; int rangeY[3001]; void init() { for(int i = 0; i \u003c= n; i++) { for(int j = 0; j \u003c= n; j++) { numX[i][j] = 0; numY[i][j] = 0; } } int sum = 0, start = 1; for(int i = 1; i \u003c= n; i++) { sum += a[i]; while(sum \u003e k) { sum -= a[start]; start++; } rangeX[i] = start; } sum = 0; start = 1; for(int i = 1; i \u003c= n; i++) { sum += b[i]; while(sum \u003e k) { sum -= b[start]; start++; } rangeY[i] = start; } } int main(void) { // freopen(\"input.txt\", \"r\", stdin); ios_base::sync_with_stdio(false); cin.tie(NULL); cin \u003e\u003e tNum; for(int tt = 0; tt \u003c tNum; tt++) { cin \u003e\u003e n \u003e\u003e k; for(int i = 1; i \u003c= n; i++) { cin \u003e\u003e a[i]; } for(int i = 1; i \u003c= n; i++) { cin \u003e\u003e b[i]; } init(); int resA = 0, resB = 0; for(int x = 0; x \u003c= n; x++) { for(int y = 0; y \u003c= n; y++) { if(x == 0 \u0026\u0026 y == 0) continue; int canWin = -1; int st, num; if(x \u003e 0) { st = rangeX[x]; num = numX[x - 1][y]; if(st \u003e 1) num -= numX[st - 2][y]; if(num \u003e 0) { canWin = 1; } } if(canWin == -1 \u0026\u0026 y \u003e 0) { st = rangeY[y]; num = numY[x][y - 1]; if(st \u003e 1) num -= numY[x][st - 2]; if(num \u003e 0) { canWin = 1; } } if(canWin == -1) { resB++; numX[x][y] = 1; numY[x][y] = 1; } else { resA++; } if(x \u003e 0) numX[x][y] += numX[x - 1][y]; if(y \u003e 0) numY[x][y] += numY[x][y - 1]; } } resA++; cout \u003c\u003c \"Case #\" \u003c\u003c tt + 1 \u003c\u003c \"\\n\"; cout \u003c\u003c resA \u003c\u003c \" \" \u003c\u003c resB \u003c\u003c \"\\n\"; } return 0; } 실제로 어거지로 고치고 그래서 코드가 깔끔하지 않다. 끝나고 다른 후기의 풀이를 봤더니 그리디로도 푸는 방법도 있는것 같다…\n3. 사다리 게임 처음에는 잘못된 방향으로 문제를 풀었는데 틀려가지고 멘탈이 박살나서 좀 쉬었다가 다시 생각해봤더니 깔끔한 풀이가 생각나서 다행히 풀 수 있었다.\n이 문제 역시 DP로 풀 수 있다. 먼저 구하고자 하는 시작 지점을 st라고 할 때, dp 배열을 다음과 같이 정의할 수 있다.\ndp[i] = st에서 i로 가는데 지워야 하는 가로선의 최소 개수\n일단 가로선이 전부 없다고 생각하자. 이러면 dp[st] = 0이고 나머지는 갈 수 없으니까 아주 큰 수(본인은 987654321을 넣었다)를 넣는다.\n이제 가로선을 위에서부터 하나씩 추가를 한다. 이때 서로 연결되는 세로선을 e1, e2라고 하면, e1과 e2를 제외한 나머지 세로선들은 이 가로선에 영향을 안 받기 때문에 값에 변화가 없다. 영향을 받는 두 세로선은 다음을 고려할 수 있다.\n추가한 가로선을 타고 가는 경우 추가한 가로선을 타고 가지 않는 경우 (지우는 경우) 1번처럼 추가한 가로선을 타고 갈 경우, 경로가 서로 바뀌기 때문에(e1으로 가던게 e2로 가고, e2로 가던게 e1으로 가게 된다.) 반대편에 있는 dp값을 가져오면 된다.\n2번처럼 가로선을 타고 가지 않을 경우, 그냥 내려가는 것이므로 자신의 dp값을 유지하면 되는데, 가로선을 제거한 경우이기 때문에 +1을 해줘야 한다.\n이제 이 2가지 경우 중 작은 것을 값으로 채택하면 된다. 이것을 식으로 요약하면\ndp[e1] = min(dp[e2], dp[e1]+1), dp[e2] = min(dp[e1], dp[e2]+1)\n이다. 이때 주의할 점은 비교할 때 쓰는 dp[e1], dp[e2]가 가로선을 깔기 전의 값이기 때문에 앞에 dp[e1]의 값이 변경되면 뒤에 dp[e2]가 잘못된 값이 나올 수도 있다. 그래서 계산하기 전에 미리 다른 변수에다가 담아서 그 변수를 이용해 계산해야 한다.\n이것을 모든 가로선에 대해서 연산을 하면 st에서 출발한 모든 경로의 값들을 구할 수 있다. 이러면 같은 st가 또 입력으로 들어왔을 때 바로 값을 낼 수 있도록 따로 배열을 만들어서 캐싱해두면 시간을 더 아낄 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 #define _CRT_SECURE_NO_WARNINGS 1 #include \u003ciostream\u003e #include \u003ccstdio\u003e #include \u003cutility\u003e using namespace std; using lli = long long int; int tNum; int n, k, m; int d[1501]; int cache[1501][1501]; pair\u003cint, int\u003e edges[2001]; void init() { for(int i = 1; i \u003c= n; i++) { d[i] = -1; for(int j = 1; j \u003c= n; j++) { cache[i][j] = -1; } } } void calc(int st) { for(int i = 1; i \u003c= n; i++) { d[i] = 987654321; } d[st] = 0; for(int i = 0; i \u003c k; i++) { int e1 = edges[i].first; int e2 = edges[i].second; int oldde1 = d[e1]; int oldde2 = d[e2]; // e1 -\u003e e2 if(oldde1 \u003c oldde2 + 1) { d[e2] = oldde1; } else { d[e2] = oldde2 + 1; } // e2 -\u003e e1 if(oldde2 \u003c oldde1 + 1) { d[e1] = oldde2; } else { d[e1] = oldde1 + 1; } } for(int i = 1; i \u003c= n; i++) { if(d[i] == 987654321) { cache[st][i] = -1; } else { cache[st][i] = d[i]; } } } int main(void) { // freopen(\"input.txt\", \"r\", stdin); ios_base::sync_with_stdio(false); cin.tie(NULL); cin \u003e\u003e tNum; for(int tt = 0; tt \u003c tNum; tt++) { cin \u003e\u003e n \u003e\u003e k \u003e\u003e m; init(); for(int i = 0; i \u003c k; i++) { int a, b; cin \u003e\u003e a \u003e\u003e b; edges[i] = { a, b }; } int res = 0; for(int kk = 0; kk \u003c m; kk++) { int s, e; cin \u003e\u003e s \u003e\u003e e; if(cache[s][s] == -1) { calc(s); } res += cache[s][e]; } cout \u003c\u003c \"Case #\" \u003c\u003c tt + 1 \u003c\u003c \"\\n\"; cout \u003c\u003c res \u003c\u003c \"\\n\"; } return 0; } 4. 범위 안의 숫자 2, 3번 문제를 푸는데 너무 많은 힘을 써서 4번은 풀 힘이 안 났다. 그리고 문제가 확 어려워지기도 해서… 그냥 생각 없이 직관적으로 풀었다.\n숫자를 골라 1을 만들 때마다 만들어지는 수들이 변경되기 때문에 수들의 집합이 자주 변하게 된다. 그래서 삽입/삭제가 빠른 BST이고 중복이 가능한, 즉 multiset을 이용했다.\n주어진 문자열에서 숫자들을 뽑아내 multiset에다가 전부 넣고, two pointer를 이용해 구간을 넘지 않게 움직이면서 최대 값을 찾는다.\n그리고 숫자를 골라 1로 만든다. 그러면 바뀌는 숫자들이 최대 k개가 생기게 되는데, multiset에 바뀌기 전 숫자들을 지우고 바뀐 숫자들을 넣는다. 그리고 이 상태에서 값을 찾는다. 그리고 원래대로 되돌린다. 이것을 모든 숫자들에 대해 반복한다.\n보면 알겠지만 그냥 무식하게 짰다. 제한 시간이 10초라서 어느 정도는 되겠지 라는 마음가짐으로 한건데 다행히? 부분점수는 받을 수 있었다.\n이외에도 map을 쓰는게 더 빠르지 않을까? 생각을 해서 map으로 바꿔보고, 구간 계산을 바뀐 수들에 대해서만 하면 되지 않을까? 해서 그렇게 해보고 해도 안 돼서 그냥 포기했다…\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 #define _CRT_SECURE_NO_WARNINGS 1 #include \u003ciostream\u003e #include \u003ccstdio\u003e #include \u003cutility\u003e #include \u003cset\u003e #include \u003cvector\u003e using namespace std; using lli = long long int; int tNum; int n, k, m; int mod; char t[50001]; multiset\u003cint\u003e d; vector\u003cpair\u003cint, int\u003e\u003e changedNums; void init() { d.clear(); mod = 1; for(int i = 1; i \u003c k; i++) { mod *= 10; } int current = 0; for(int i = 0; i \u003c k; i++) { current *= 10; current += t[i] - '0'; } d.insert(current); for(int i = k; i \u003c n; i++) { current = current % mod; current *= 10; current += t[i] - '0'; d.insert(current); } } int calc() { int res = 0; auto left = d.cbegin(); auto right = left; int cnt = 1; res = 1; while(1) { right++; if(right == d.cend()) break; cnt++; while(*left + m \u003c *right) { cnt--; left++; } if(res \u003c cnt) res = cnt; } return res; } void Change(int idx) { changedNums.clear(); int current = 0; int left = idx - k + 1; if(left \u003c 0) left = 0; for(int i = 0; i \u003c k; i++) { current *= 10; current += t[left + i] - '0'; } changedNums.push_back({ current, 0 }); for(int i = left + k; i \u003c n; i++) { if(i - k \u003e= idx) break; current = current % mod; current *= 10; current += t[i] - '0'; changedNums.push_back({ current , 0 }); } // char old = t[idx]; t[idx] = '1'; int cIdx = 0; current = 0; for(int i = 0; i \u003c k; i++) { current *= 10; current += t[left + i] - '0'; } changedNums[cIdx++].second = current; for(int i = left + k; i \u003c n; i++) { if(i - k \u003e= idx) break; current = current % mod; current *= 10; current += t[i] - '0'; changedNums[cIdx++].second = current; } t[idx] = old; for(int i = 0; i \u003c changedNums.size(); i++) { auto findIter = d.find(changedNums[i].first); d.erase(findIter); d.insert(changedNums[i].second); } } void Rollback() { for(int i = 0; i \u003c changedNums.size(); i++) { auto findIter = d.find(changedNums[i].second); d.erase(findIter); d.insert(changedNums[i].first); } } int main(void) { // freopen(\"input.txt\", \"r\", stdin); ios_base::sync_with_stdio(false); // cin.tie(NULL); cin \u003e\u003e tNum; for(int tt = 0; tt \u003c tNum; tt++) { cin \u003e\u003e n \u003e\u003e k \u003e\u003e m \u003e\u003e t; init(); int res = calc(); for(int i = 0; i \u003c n; i++) { if(t[i] == '1') continue; Change(i); int r2 = calc(); Rollback(); if(r2 \u003e res) res = r2; } cout \u003c\u003c \"Case #\" \u003c\u003c tt + 1 \u003c\u003c \"\\n\"; cout \u003c\u003c res \u003c\u003c endl; } return 0; } Round 1은 커트라인이 널널하기 때문에 개인적인 생각으로는 1문제 + 다른문제 부분점수면 무난하게 통과할 것 같다.\nRound 2가 2주일 정도 뒤에 열리는데 솔직히 통과할 수 있을지는 모르겠다. 이번에 문제 풀 때도 생각이 빠르게 나지 않았고, 쓸때없는 것에 시간낭비도 했다. 지금 하고 있는게 많긴 한데… 그래도 열심히 준비해야겠다.\n","description":"","tags":[],"title":"SCPC 2020 Round1 후기","uri":"/posts/2020/scpc-2020-round1-review/"},{"categories":["Project","MelonCrawler4YTMusic"],"content":"필자는 음악 스트리밍 서비스로 Youtube Music을 이용하고 있다. Youtube Premium에 포함되어 있길래 그냥 같이 쓰고있다. 플레이 리스트 생성이나 자동재생 기능은 만족하면서 쓰고있지만, 차트 기능이 좀 부족한 것 같았다. 물론 한국 인기곡 Top100 차트가 있긴 한데 유행하는 신곡이 나와도 업데이트가 빠르게 되는 것 같지 않다.\n한국 노래 차트하면 대표적으로 멜론 차트가 있다. 그래서 이 멜론 차트를 주기적으로 크롤링해서 내 플레이리스트에 넣으면 되겠다! 라는 생각이 들었다. 하지만, Youtube API는 있는데 아무리 찾아봐도 Youtube Music API는 찾을 수가 없었다.\n그렇게 구현을 포기하고 있다가 어느날, 이 API를 어떤 사람이 직접 구현한 것을 발견했다! 그것을 보고 바로 개발을 시작했다.\nAPI 파악 이 API는 python으로 만들어져 있다. python은 오랜만에 해보는 언어라서 어떻게 개발 환경을 만들어야 할지 좀 찾아봤다. (자세한 구축 방법은 다음 문단에)\n다행히 문서가 잘 정리되어있어서 API를 쓰는데 어려움 점은 없었다.\n이 API는 크게 인증된 요청(Authenticated requests) 과 인증되지 않은 요청(Unauthenticated requests) 두 가지로 나눌 수 있다.\n인증된 요청은 말 그래도 사용자 인증이 된 상태에서 하는 요청이다. 보통 유저와 관련된 요청(플레이 리스트 추가, 추천…)들이 여기에 속한다. 인증된 요청을 쓰기 위해서는 로그인된 유저의 쿠키가 필요하다. 아마 이 API는 Youtube Music에게 HTTP 요청을 보내 받은 값을 처리하는 구조인 것 같은데, 그때 사용하는 것 같다.\n인증되지 않은 요청은 이와 반대로 사용자 인증이 필요 없는 요청이다. 검색이나 곡 정보 보기 같은 것들이 해당한다.\n개발 환경 구축 API가 python으로 만들어져 있기 때문에 python 개발 환경 구축방법들을 찾아보았다.\n일단 python은 그냥 쓰기에 좋지 않다. 모든 환경이 각 프로젝트에 맞춰져 있지 않고 글로벌하게 맞춰져 있기 때문이다. Python 프로그램 자체가 그런것은 그럴 수 있는데, 문제는 라이브러리 패키지도 그렇다는 점이다.\n예를 들어 AProject에서 B-1.0.2 라이브러리를 쓴다고 하자. 이때 새로운 BProject를 만들고 이 프로젝트는 B-4.5.1 라이브러리를 쓰도록 설정했다. 이러면 python(정확히는 pip)은 기존에 설치되어있던 B-1.0.2를 B-4.5.1로 업데이트 하게 된다. 그러면 이제 AProject는 B-4.5.1 라이브러리를 쓰게 되고, 버전이 의도치 않게 올라갔기 때문에 문제가 발생할 가능성이 생기게 된다.\n이 문제를 해결하기 위해서는 각 프로젝트마다 독립된 환경을 구축할 필요가 있다. 이러한 것들을 도와주는 여러 프로그램들이 있는데, 필자는 Virtualenv를 사용했다. Virtualenv는 쉽게 말해 라이브러리랑 python 그 자체를 한 폴더에다가 넣어두고, 실제로 사용할 땐 그 폴더 안에서 동작하도록 가상화해준다.\n사용법은 아주 간단하다. 먼저 Virtualenv를 설치해 준다. (이미 설치가 되어있다면 할 필요 없음)\n$ sudo pip install virtualenv Windows의 경우 sudo를 빼주면 된다.\n설치가 되었으면 가상환경을 구축할 프로젝트 폴더로 가서\n$ virtualenv env 를 입력하면, env라는 폴더가 생기게 된다.\n폴더가 생겼다고 바로 쓸 수 있는 것은 아니다. 작업을 시작하기 전에 수동으로 활성화해야 한다.\n$ source env/bin/activate Windows의 경우 ./env/Scripts/activate 라고 입력하면 된다.\n를 입력하면 가상환경이 활성화가 된다. 이제 pip나 python 명령어를 실행하면 env폴더 내부에서 처리하게 된다.\n작업을 다 끝내고 가상환경을 비활성화 하고 싶으면 간단하게\n$ deactivate 를 입력하면 된다.\n이외에 여러가지 찾아보니까 부실한 pip를 대신해 Poetry라는 패키지 매니저도 있었다. 하지만 프로젝트 규모도 크지 않고, 무엇보다 귀찮아서 그냥 pip를 쓰기로 했다.\n이외에 편집기로는 기존에 쓰던 VSCode를 이용했다.\n멜론 차트 크롤링 웹 크롤링을 구글에 검색하면 대다수가 python을 이용한 크롤링이라서 정보를 아주 쉽게 얻을수가 있다. 방법을 간단히 요약하자면,\nrequest를 이용해 웹 페이지를 가져온다. BeautifulSoup를 이용해 가져온 웹 페이지에서 원하는 정보를 뽑아낸다. 자세한 방법은 검색하면 많이 나오니 여기서는 생략하겠다.\n멜론 차트에서 정보를 뽑아오기 위해서는 먼저 차트 페이지가 어떤 구조로 되어있는가를 알아야 한다.\n차트 페이지에서 얻어야 할 정보는 곡 이름, 앨범, 그리고 작곡가이다. 얻고자 하는 정보에 마우스 우클릭-\u003e검사(혹은 Ctrl-Shift-I)를 누르면 해당 element로 이동하기 때문에 좀 더 편리하게 구조를 분석할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 \u003ctable\u003e ... \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003e...\u003c/td\u003e \u003ctd\u003e...\u003c/td\u003e \u003ctd\u003e...\u003c/td\u003e \u003ctd\u003e \u003cdiv class=\"wrap\"\u003e \u003cdiv class=\"wrap_song_info\"\u003e \u003cdiv class=\"ellipsis rank01\"\u003e \u003cspan\u003e \u003ca ...\u003e 곡 이름 \u003c/a\u003e \u003c/span\u003e \u003c/div\u003e \u003cdiv class=\"ellipsis rank02\"\u003e \u003ca ...\u003e 작곡가 \u003ca/\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/td\u003e \u003ctd\u003e \u003cdiv class=\"wrap\"\u003e \u003cdiv class=\"wrap_song_info\"\u003e \u003cdiv class=\"ellipsis rank03\"\u003e \u003ca ...\u003e 앨범 \u003c/a\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/td\u003e ... \u003c/tr\u003e \u003ctr\u003e...\u003c/tr\u003e ... \u003c/tbody\u003e \u003c/table\u003e 구조를 간략하게 분석한 내용이다. 차트 자체는 table로 이루어져 있고, 각 곡들은 table에 한 줄씩 차례대로 들어가있다. 각 줄의 4번째 \u003ctd\u003e랑 5번째 \u003ctd\u003e가 각각 곡 이름+작곡가, 앨범의 정보를 가지고 있다.\n이 정보만 가지고도 충분히 뽑아올 수 있지만, 좀 더 살펴보니 더 편한 방법이 있었다. 곡 이름, 작곡가, 앨범 정보들이 모두 \u003cdiv class=\"wrap_song_info\"\u003e 안에 있어서 저 클래스만 가지고 뽑을 수도 있겠다 라는 생각이 들었다. 실제로 CSS Selector로 .wrap_song_info 를 검색하니까 [1등 곡 이름+작곡가, 1등 곡 앨범, 2등 곡 이름+작곡가, 2등 곡 앨범, …] 이렇게 손쉽게 정보를 뽑아올 수 있었다.\n1 2 3 4 5 6 7 8 9 10 11 12 melon_page_req = requests.get(\"https://www.melon.com/chart/index.htm\") soup = BeautifulSoup(melon_page_req.content, \"html.parser\") song_infos = soup.select(\".wrap_song_info\") for i in range(0, len(song_infos), 2): tmp = song_infos[i].find_all(\"div\") title = tmp[0].span.a.text artist = tmp[1].span.a.text album = song_infos[i + 1].div.a.text self.melon_song_infos.append((title, artist, album)) 먼저 BeautifulSoup를 이용해 .wrap_song_info인 요소들을 다 가져온다. 그리고 반복문을 돌면서 요소들 안에 있는 곡 이름, 작곡가, 앨범 정보들을 빼서 배열에 튜플로 넣어준다.\n완벽해! 하고 프로그램을 돌리니까 오류가 발생했다… 응답 내용을 보니 406 Not Acceptable 이 찍혀 있었다. 그래서 검색해보니까 requests의 User-Agent가 몇몇 사이트에서는 막는 경우가 있다고 한다.\n1 2 3 4 5 6 melon_page_req = requests.get( \"https://www.melon.com/chart/index.htm\", headers={ \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.105 Safari/537.36\" }, ) 그래서 그냥 헤더에 Chrome의 User-Agent 값을 넣었다. 다행히 잘 작동했다.\nYoutube Music에 넣기 ID 찾기 Youtube Music에 음악을 넣기 위해서는, 각 곡의 ID를 알아야 한다. 가지고 있는 정보는 곡 이름, 작곡가, 앨범인데 다음과 같은 방식으로 찾았다.\n곡 이름을 Youtube Music에 검색한다. 검색 결과중에 앨범명이 일치하는 곡이 있으면 그 곡을 선택한다. 없을 경우, 작곡가와 일치하는지 확인 후 있으면 그 곡을 선택한다. 그래도 없을 경우, 그냥 첫 번째 곡을 선택한다. 일치하는지 여부 확인은 두 문자열이 정확히 일치하는지를 확인하지 않고, 문자열 중 하나가 다른 문자열에 포함될 경우를 일치한다고 정했다. 멜론에서 쓰는 작곡가/앨범 이름이 Youtube Music하고 다른 경우가 종종 있어서 이런 방식을 사용했다. 특히 영어 이름인 경우에 이런 예외가 많았는데, 예를 들어 멜론에서 아이유 라는 이름이 Youtube Music에서는 IU(아이유) 라고 표기되어 있다.\n1 if album_name.find(song_album) != -1 or song_album.find(album_name) != -1: 포함 여부는 find()함수를 쓰면 쉽게 알 수 있다.\n플레이리스트에 넣기 플레이리스트에 넣는 방법은 간단하다.\n이전에 플레이리스트를 만들어서 해당하는 플레이리스트 ID를 가지고 있다면, 4번으로 넘어간다. 해당 계정이 가지고 있는 플레이리스트를 전부 가져온 뒤, 해당하는 플레이리스트가 있으면 그 플레이리스트 ID를 가져온다. 없을 경우 플레이리스트를 만들고 해당 ID를 가져온다. 플레이리스트에 있는 모든 곡들을 제거한다. 플레이리스트에 미리 찾아둔 곡 ID들을 이용해 곡들을 전부 넣는다. 플레이리스트에 곡들을 넣을 때 주의할 점이 있는데, 곡 ID들이 중복되어서는 안 된다. 중복으로 넣으려 하면 이미 있는 곡이라고 중간에 곡 넣는 작업이 중단되기 때문이다.\n검색 정확도 높이기 이렇게 코딩을 하고 실제로 돌려보니 잘 돌아갔다. 하지만 의도한 것과는 다른 곡들이 들어가는 경우가 종종 있었다. 그래서 이런 오류들을 고치기 위해 여러 추가 작업들을 했다.\n작곡가보다 앨범을 우선해서 확인 초기 버전에서는 곡 검색 후 작곡가가 먼지 일치하는지를 확인했었다. 하지만 이 방식으로 하니까 종종 엉뚱한 곡이 들어가는 경우가 생겼다. Youtube Music에서 작곡가 명이 조금씩 다르기 때문이다.\n왼쪽이 멜론에서의 곡 정보, 오른쪽이 Youtube Music에서의 곡 정보이다. 다시 여기 바닷가 라는 곡의 작곡가가 멜론에서는 싹쓰리 (유두래곤, 린다G, 비룡) 으로 되어있고 Youtube Music에서는 싹스리 (유두래곤\u0026린다G\u0026비룡) 으로 되어있다. , 가 \u0026 로 바뀌어서 서로 일치하지 않는다고 판단하고, 오히려 전혀 다른 곡이지만 작곡가 명이 일치하는 그 여름을 틀어줘가 대신 들어가게 된다.\n또한 어떤 작곡가는 한글명만 쓰여있고, 어떤 작곡가는 한글명(영어명) 으로 쓰여있고, 어떤 작곡가는 영어명만 쓰여있는 등 일관성이 없기도 하다.\n이처럼 작곡가 이름은 서로 다르거나 일관성이 없는 경우가 많은 반면에, 앨범 이름은 대체로 멜론과 Youtube Music 둘 다 같은 이름을 가지는 경우가 많았다. 그래서 앨범이 작곡가보다 더 신뢰할만하다고 판단해, 앨범이 먼저 일치하는지 확인하도록 바꾸었다.\n일치 여부 확인 전에 전부 소문자로 바꾸기 앨범을 먼저 확인하도록 바꾸었어도 종종 오류가 발생해서 확인해봤더니 이런 경우도 있었다.\n위쪽의 멜론에서는 YOU NEVER WALK ALONE 으로 전부 대문자로 되어 있는 반면에, 아래쪽의 Youtube Music에서는 You Never Walk Alone 으로 단어의 첫 글자만 대문자로 되어있다. 그래서 서로 일치하는지 확인하기 전에 모든 영문자들을 소문자로 바꾸는 전처리과정을 추가했다. Python에서는 이 과정을 문자열 뒤에 .lower()만 붙이면 된다.\n검색 결과를 한국어로 바꾸기 이런저런 작업들을 해도, 근본적으로 검색 결과가 영어로 나오기 때문에 오류가 이따금씩 발생하고 있었다. API가 아직 한국어를 지원하지 않아서 그렇다. 그래서 한국어를 지원하도록 API를 수정하기로 했다.\n다행히 이 문서를 보고 추가 언어 지원을 할 수 있다고 한다. 여기서 ytmusicapi는 gettext를 사용하고 있다는 것을 알 수 있었다.\n.po 파일을 수정하고 (Poedit을 사용했다), 파일들을 라이브러리 폴더에 넣고, 언어 설정을 ko로 바꾸었다. 검색 요청을 날려보니 다행히 한국어로 잘 나왔다.\n그런데 몇몇 검색에서는 결과값이 전혀 안 나오고 []만 나오는 현상이 발생했다. 실제로 웹에서 검색을 하면 잘 나와서 검색 결과가 없는게 아닌데 라는 생각으로 라이브러리를 뜯어보았다. 그리고 문제점을 발견했다.\n1 2 3 def to_int(string): number = string.split(' ')[0] return locale.atoi(number) 유틸 관련 파일에 있는 to_int()함수이다. 구현이 그냥 문자열을 띄어쓰기를 기준으로 나누고 나눈 것의 첫번째를 숫자로 바꾼다. 이 함수가 문제였다.\n위 함수는 숫자가 있는 데이터(조회수, 좋아요 수…)에서 숫자 정보만 빼기 위해 만든 함수이다. 영미권 언어들은 저런 구현이 가능한게, ‘153 songs’, ‘156k follwers’ 처럼 왠만하면 무조건 숫자가 앞에 나오게 된다. 하지만 한국어의 경우, ‘노래 153곡’, ‘팔로우 15.6만명’ 처럼 앞에 숫자의 정보가 있고, 숫자 뒤에 접미사까지 붙게 된다. 이 때문에 한국어에서 저 함수를 호출하면 ‘노래‘를 숫자로 변환하려고 하게 되고, 예외가 발생해서 올바른 값이 나오지 않게 된다.\n1 2 3 4 5 6 7 8 9 10 11 def to_int(string): start_decimal_idx = -1 end_decimal_idx = -1 for i in range(0, len(string)): if string[i].isdecimal() == True: end_decimal_idx = i if start_decimal_idx == -1: start_decimal_idx = i number = string[start_decimal_idx : end_decimal_idx + 1] return locale.atoi(number) 그래서 문자열에서 숫자만 추출해서 변환하도록 코드를 수정했다. 문자열을 돌면서 가장 처음에 나온 숫자의 위치와 가장 나중에 나온 숫자의 위치를 알아내고, 그 위치를 기준으로 문자열을 자른 후 그 문자열을 변환하게 만들었다.\n이 코드 말고도 다른 곳에서도 비슷하게 숫자를 처리하는 로직이 있는데, 일단 저 함수만 수정해도 잘 돌아갔다. 그래서 저런 로직들을 싹다 수정해서 PR을 올리려고 했는데, 골치아픈 문제가 있었다.\n숫자가 적을 경우는 문제가 안 되는데, 숫자가 많아져서 줄어들게 될 경우 문제가 발생한다. 숫자 뒤에 k, m이나 천, 만 같은 접미사가 붙게 되어서 숫자만 추출하면 저 접미사가 빠져서 원래 숫자보다 더 적게 나오게 된다. 그렇다고 뒤에 한 글자만 더 포함하자니 접미사가 안 붙는 경우도 있고, 언어마다 다른 경우도 있는 등 고려할 게 많았다. 그리고 이 모든 것들을 수정하기에는 귀찮기도 해서… 그래서 그냥 오류가 안 날 정도로만 수정해서 쓰고있다. 어차피 숫자 데이터는 안 쓰기 때문에…\n배포 배포는 이전에 했던 프로젝트랑 비슷하게 Docker를 이용했다.\n1 2 3 4 5 6 7 8 9 10 11 FROM python:3.8-alpine WORKDIR /app/MelonCrawler4YTMusic COPY main.py ./ COPY requirements.txt ./ RUN pip install -r requirements.txt COPY ytmusicapi_modified /usr/local/lib/python3.8/site-packages/ytmusicapi CMD [ \"python3\", \"main.py\" ] 파일을 복사하고, pip로 패키지 설치하고, 실행하는 간단한 구조이다. 실행하기 전에 ytmusicapi 수정한 부분을 덮어씌우는 과정이 있다. 이 Dockerfile을 이용해 docker image를 만들면 된다.\n1 2 3 4 5 6 7 8 9 10 11 12 version: '3' services: mainserver: image: \"cube219/melon-crawler:latest\" container_name: melon-crawler-server volumes: - ./logs:/app/MelonCrawler4YTMusic/log environment: COOKIE: [MY_COOKIE] PLAYLIST_NAME: 멜론 차트 100 UPDATE_INTERVAL: 172800 # 2 days 그리고 만든 docker image를 띄우면 된다. 필자는 docker-compose를 사용했다. 환경 변수 설정이나 volume 마운트 설정이 편하기 때문이다.\n느낀 점 오랜만에 쓰는 python이라 그런지 생각보다 재미있었다.\n완성하긴 했는데 막상 별로 사용하지는 않을 것 같다. 노래를 자주 듣지 않기도 하고, 요즘은 그냥 Youtube 추천 노래들만 듣고있다. 그래도 한 번 만들어보고 싶었던 것이여서 만족한다.\n","description":"","tags":[],"title":"MelonCrawler4YTMusic 개발기","uri":"/posts/2020/melon-crawler-for-ytmusic-development/"},{"categories":["Project","WebPageAlerter"],"content":"요즘 게임 엔진 프로젝트만 계속 진행하다 보니까 너무 지루하고 힘들어서 의욕이 나지 않았다. 그래서 잠깐 쉴 겸 새로운 서브 프로젝트를 하나 진행해야겠다고 생각했다. 어떤 것을 할까 생각하다가 예전부터 필요하다고 생각했던 것을 떠올렸다.\n나는 여러 개발자 블로그나 웹사이트들을 자주 둘러보는 편이다. 재미있어 보이는 글이 올라오는 블로그나 사이트들을 발견하면 즐겨찾기해서 자주 살펴본다. 하지만 이런 사이트들에서 새로운 글이 올라왔나 매번 확인하는 것은 많이 귀찮은 일이다. 그래서 이러한 확인을 자동으로 하고 새로운 글이 올라오면 따로 저장을 해 알려 주는 알리미 서비스를 만들면 좋겠다는 생각을 자주 했다. 그래서 이번 서브 프로젝트로 이것을 구현하기로 결정했다.\n무엇으로 만들까? 새로운 글이 올라왔는지 확인하기 위해서 주기적으로 크롤링을 해야 하기 때문에 서버가 필요하다. 서버를 무엇으로 만들지 고민하다가 가장 먼저 python이 떠올랐다. 당장 구글에 웹 크롤링이라고 검색하면 python을 이용해 만드는 방법들이 정말 많이 있고, 예전에 간단히 써본 경험도 있다. 그래서 python을 선택하자고 생각을 했었다.\n그러다가 최근 JavaScript를 써본 적이 있었는데, 쓰다 보니까 동적 타입 언어라서 그런지 생각보다 불편했다. 특히 함수 호출에서 많은 불편함을 느꼈다. 많은 JavaScript 라이브러리에서 API를 호출 할 때 매개변수로 Object를 넣는 경우가 많은데, 이때 Object 안에 어떤 값들을 넣어야 하는지 에디터에서는 알 수가 없다. 또한 반환값으로 Object를 반환하면 역시 안에 어떤 값들이 들어있는지 알 수 없다. 그래서 계속 문서를 보거나 라이브러리 코드를 봐야 하는 번거로움이 있었다.\n이러한 불편한 점이 있어서 JavaScript에 정적 타입을 얹은 TypeScript를 한 번 써보고 싶다고 계속 생각을 했었고, 마침 이 프로젝트를 하면서 써보면 좋겠다고 생각해서 python에서 TypeScript로 변경했다.\n프론트엔드쪽은 그냥 이전에 써본 Vue.js를 썼다. 큰 프로젝트도 아니고 익숙한 걸 써서 빠르게 개발하고 싶었다. 여기서 UI는 quasar framework를 썼다. 여러가지 찾아봤는데 이 프레임워크가 다양한 기능(버튼에 진행 중 표시, Infinite 스크롤…)들이 있고 나중에 Web Application으로도 쉽게 만들 수 있을 것 같아서 선택했다.\n기획 먼저 어떠한 기능들이 있어야 하는지 생각을 해보았다.\n웹 사이트 새 글들을 저장할 웹 사이트 정보 이름 / 주소 / 설명 / 카테고리 / 크롤링주소 / CSS Selector / … 웹 사이트들을 추가, 제거, 조회 새 글들을 확인하기 위해서는 주기적으로 웹 크롤링을 해서 확인 보통 최근 글 리스트가 나오는 페이지를 크롤링 CSS Selector를 이용해 가장 최신 글로 가는 \u003ca\u003e 태그의 링크로 최신 글인지 확인 글(페이지) 새 글이 올라오면 푸시 알림으로 알려주고 따로 서버에 저장해둠 저장된 글들은 최신 글부터 차례대로 보여지며, 여러 분류로 나눠서 볼 수 있음 저장된 새 글들은 읽었으면 읽었다는 체크가 자동으로 됨 글은 수정은 불가능하나, 제거는 가능함 글은 별도의 장소에 보관할 수 있음 (중요한 글) 글의 정보 제목 / 내용 / 주소 / 카테고리 / 작성시간 / 커버이미지 / … 새로운 글은 어떻게 확인하나? 일정 주기마다 등록한 웹사이트 페이지를 크롤링한다. 크롤링한 페이지에서 가장 마지막에 작성된 글의 정보를 가져온다. 이때 CSS Selector를 이용한다. 저장된 마지막 글 정보를 위에서 크롤링한 정보와 비교한다. 그림에서는 제목으로 비교하지만, 실제로는 글의 주소(\u003ca\u003e 태그의 href)로 비교한다. 둘이 서로 다를 경우, 새로운 글이 올라왔다는 것이므로 해당 글에 접근해 정보들을 가져온다. 이때 Open Graph 정보를 이용한다. 마지막 글 정보를 업데이트 한다. 구현(Backend) 위 기획을 바탕으로, 백엔드 구조를 구상했다.\n최대한 기능 별로 분리를 하려고 헀고, 흐름을 무조건 중심(Core)을 거치게 해서 최대한 깔끔하게 처리하려고 했다.\n기본 인터페이스 (WebSiteInfo, WebPageInfo) 먼저 웹 사이트 / 웹 페이지 인터페이스들을 정의했다. 이 정의들은 여러 곳에서 쓰이기 때문에 Utility.ts에 정의했다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 export interface WebSiteInfo { _id: string; title: string; url: string; crawlUrl: string; cssSelector: string; lastUrl: string; category: string; checkingCycleSec: number; isDisabled: boolean; } export interface WebPageInfo { _id: string; siteId: string; siteTitle: string; title: string; url: string; imageUrl: string; desc: string; category: string; time: Date; isRead: boolean; isArchieved: boolean; } WebSiteInfo는 크롤링할 웹 사이트들의 정보들을 정의했다. 웹사이트의 기본적인 정보와 새로운 글이 올라왔는지 확인하기 위한 정보들을 가지고 있다.\nWebPageInfo에는 저장한 페이지 정보들을 정의했다.\n페이지 정보 가져오기 페이지 정보는 위에서 언급했듯이 Open Graph 태그를 이용해 가져왔다.\nOpen Graph에는 많은 정보들이 있지만 그중에서 title, url, image, description만 이용했다.\n1 2 3 4 \u003cmeta property=\"og:title\" content=\"제목\"\u003e \u003cmeta property=\"og:url\" content=\"https://blog.cube219.me/...\"\u003e \u003cmeta property=\"og:image\" content=\"...image.png\"\u003e \u003cmeta property=\"og:description\" content=\"설명\"\u003e 이런 태그들을 찾아서 데이터를 뽑아야 하는데, cheerio를 사용해 뽑아냈다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 const $ = cheerio.load(res); let selected: Cheerio; let title = \"\"; selected = $('meta[property=\"og:title\"]'); if(selected.length != 0) { title = selected[0].attribs.content; } else { selected = $('title'); if(selected.length != 0) { title = selected.text(); } } let url = \"\"; selected = $('meta[property=\"og:url\"]'); if(selected.length != 0) { url = selected[0].attribs.content; } else { url = pageUrl; } let imageUrl = \"\"; selected = $('meta[property=\"og:image\"]'); if(selected.length != 0) { imageUrl = selected[0].attribs.content; } let desc = \"\"; selected = $('meta[property=\"og:description\"]'); if(selected.length != 0) { desc = selected[0].attribs.content; } CSS Selector로 해당하는 태그를 선택해 해당 태그의 정보를 가져올 수 있다. jQuery와 상당히 유사해서 쉽게 쓸 수 있었다.\n만약 페이지에 Open Graph 정보가 없으면 최소한의 정보인 title, url만 각각 \u003ctitle\u003e태그, 페이지 url로 대체한다.\nWebSiteWatcher 말 그대로 웹 사이트에 새로운 글이 올라왔는지 감시하는 감시자(Watcher) 이다. 등록한 웹 사이트마다 1개씩 생성된다.\n감시자들은 생성이 되면 일정 주기로 해당 웹 사이트에 새로운 글이 올라왔는지 확인을 한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public run() { if(this.siteInfo.isDisabled == true) { return; } if(!this.siteInfo.checkingCycleSec) { this.siteInfo.checkingCycleSec = 3600; DB.updateWebSite(this.siteInfo._id, { checkingCycleSec: 3600 }); } // Delay checking when initialized // because of preventing checking many sites at same time const delayTimeSec = Math.random() * this.siteInfo.checkingCycleSec; this.intervalId = setTimeout(this.checkImmediately.bind(this), delayTimeSec * 1000); } public checkImmediately() { if(this.intervalId) { clearTimeout(this.intervalId); } this.runInternal(); this.intervalId = setInterval(this.runInternal.bind(this), this.siteInfo.checkingCycleSec * 1000); } 주기적으로 검사를 해야 하기 때문에 setInterval함수를 이용했다. 여기서 run함수는 실행하자 마자 바로 검사를 하는 것이 아니라 일정 딜레이 후 검사를 하는데, 이는 서버가 켜지면서 등록된 모든 Wathcer들이 바로 동시에 검사하는 것을 막기 위해서다. 굳이 필요할 것 같진 않은데 그래도 혹시나 해서 넣었다.\n이제 웹 사이트에 새로운 글이 올라왔는지 확인을 하는 함수를 만들어야 한다. 확인하는 방법으로는 지정한 웹 사이트 HTML을 가져오고, 최신 글로 가는 링크를 뽑아서 기존에 저장한 링크와 같은지 확인해 안 같으면 새로운 글이 올라온 것으로 확인할 수 있다.\n예를 들어 Unity Blog에서 새로운 글을 확인하고 싶다면, 이렇게 최신 글의 \u003ca\u003e태그를 CSS Selector(여기서는 .post-heading \u003e a)로 뽑아낸 다음 해당 주소를 이용해 판별할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 private async checkNewPage() { this.isBusy = true; let res: any; try { res = await rq(this.siteInfo.crawlUrl); } catch(e) { let err = new InvalidUrlError(this.siteInfo.crawlUrl); err.message = e.message; throw err; } try { const $ = cheerio.load(res); const aElement = $(this.siteInfo.cssSelector)[0]; const pageUrl = relToAbsUrl(aElement.attribs.href, this.siteInfo.url); if(this.siteInfo.lastUrl != pageUrl) { await this.savePage(pageUrl); } } catch(e) { let err = new InvalidCssSelectorError(this.siteInfo.cssSelector); err.message = e.message; throw err; } this.isBusy = false; } 실제 코드에서도 crawlUrl로 지정한 페이지를 가져오고, cssSelector로 해당 \u003ca\u003e 태그의 href 속성을 가져온다. 그리고 이 주소가 lastUrl과 다르면, 새로운 글이 올라왔다는 뜻이므로 해당 페이지를 저장한다.\n1 2 3 4 5 6 7 8 9 10 11 private async savePage(pageUrl: string) { const info = await getPageInfo(pageUrl); info.siteId = this.siteInfo._id; info.siteTitle = this.siteInfo.title; info.category = this.siteInfo.category; await this.core.insertPage(info, pageUrl); this.siteInfo.lastUrl = pageUrl; } 페이지 저장은 간단하게 getPageInfo를 통해 해당 페이지 정보를 얻고, 저 함수로 얻을 수 없는 사이트 정보, 카테고리도 추가한 후 DB에 해당 페이지를 삽입한다. 그리고 lastUrl을 갱신한다.\nDB DB로는 mongoDB를 이용했다. 노드에서는 저걸 많이 쓰기도 하고, 뭔가 새로운 것을 해보고 싶었다.\n이제 이걸 노드에서 어떻게 사용해야 할지 검색해보니까 보통 mongoose라는 라이브러리를 많이 이용했다. 이 라이브러리는 스키마를 정의를 하게 해서 좀 더 견고하게 DB를 다룰 수 있게 도와주고, 쿼리 빌더로 쉽게 쿼리를 만들수 있다. 특히 쿼리 빌더 기능이 편리했다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 let query: mongoose.DocumentQuery\u003cISavedWebPage[], ISavedWebPage\u003e; if(fromArchieved == false) { query = SavedWebPageModel.find(condition); } else { query = ArchievedWebPageModel.find(condition); } if(params.afterId) { query.where(\"_id\").lt(params.afterId); } else if(params.startIndex) { query.skip(params.startIndex); } if(params.count) { query.limit(params.count); } const queryRes = await query.sort({ _id: -1 }); 저장된 웹 페이지들을 가져오는 코드의 일부분이다. 저장된 페이지들을 가져올 때는 특정 개수나 특정 id이후, 특정 index이후 등 여러 조건들이 들어가게 되고, 이는 조건 JSON 객체를 복잡하게 만든다. 이것을 쿼리 빌더를 이용하면 .limit, .where와 같은 함수를 이용해 조건을 붙일 수 있고, 좀 더 직관적으로 코드를 짤 수 있었다.\n컬렉션 (RDBMS의 테이블에 해당) 으로는 해당 서버의 버전 정보를 담는 app_infos, 웹 사이트 정보인 web_site_infos, 저장된 웹 페이지인 saved_web_pages, 따로 보관한 웹 페이지인 archieved_web_pages, 그리고 카테고리인 category_infos로 나누었다.\napp_infos는 현재 실행 중인 서버의 버전을 담는 컬렉션이다. 이 데이터는 추후에 서버가 업데이트 되어서 DB구조가 바뀌어 수정을 해야 할 때 쓰인다. 예를 들어 0.3.0 버전부터 카테고리를 category_infos로 옮겼는데 기존에 들어있던 웹 사이트들의 카테고리 정보를 가져와야 하기 때문에 추가적인 작업이 필요하다. 이때 이 정보를 가져오고 0.3.0 버전보다 아래이면 위 작업을 하는 방식이다.\nweb_site_infos는 말 그대로 등록한 웹 사이트의 정보들을 저장하고 있다.\nsaved_web_pages와 archieved_web_pages는 역시 말 그대로 저장된/따로 저장한 웹 페이지들을 저장하고 있다.\ncategory_infos는 등록된 카테고리 정보들을 저장하고 있다. 이 데이터는 개발하다 보니까 카테고리들만 따로 필요하게 되는 경우가 생겨서 추가했다.\n코드는 최대한 컬렉션 별로 해당 정보를 추가/제거/수정하는 함수들을 각각 만들었다.\n1 2 3 4 5 async getWebSites() async getWebSite(id: string) async insertWebSite(info: WebSiteInfo) async deleteWebSite(id: string, deleteAllPages: boolean = false) async updateWebSite(id: string, params: UpdateWebSiteParams) 예를 들어 웹 사이트의 경우 사이트를 검색/추가/수정/제거 기능을 하는 함수들을 만들고 함수 내부에서는 web_site_info 컬렉션을 수정하도록 되어있다.\nAPIServer 웹 사이트를 등록/수정하거나 저장된 페이지들을 볼 수 있는 RESTful API 서버이다. 외부하고 유일하게 통신할 수 있는 곳이다.\n원래는 Express.js를 쓸려고 했는데 지인이 Koa를 써보라고 해서 써보았다. 써보니까 await/async를 쓸 수 있다는 점이 좋았다. 그리고 Express 만들던 사람들이 만들어서 그런지 기능이나 쓰는 방법들이 Express랑 거의 유사했다. 그래서 쉽게 사용할 수 있었다.\n인증 시스템 인증 토큰으로는 JSON Web Token(JWT)을 이용했다. JWT는 다른 토큰들과는 다르게 서버에서 관리할 필요가 없는데, 이는 토큰 내부에 이 토큰이 올바른지 확인하는 서명이 있기 때문이다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // koa 초기화하는 부분 일부 코드 ... if(this.enableAuth == true) { this.koaApp.use(this.authMiddleware.bind(this)); } ... private async authMiddleware(ctx: koa.ParameterizedContext, next: () =\u003e Promise\u003cany\u003e) { const token = ctx.headers[\"x-access-token\"] as string; if(!token) { ctx.response.status = 401; return; } try { jwt.verify(token, this.jwtSecretKey); } catch(e) { if(e instanceof jwt.TokenExpiredError) { ctx.response.status = 401; ctx.body = \"Token expired\"; return; } else if(e instanceof jwt.JsonWebTokenError) { ctx.response.status = 401; ctx.body = \"Token error\"; return; } else { throw e; } } await next(); } 토큰 확인은 요청한 주소로 라우팅 하기 전에 미들웨어를 하나 거쳐서 확인한다. 이 미들웨어에서는 x-access-token에 들어있는 토큰을 가져와서 이 토큰이 유효한지 jwt.verify함수를 통해 확인하고, 유효하면 다음 단계로 넘어가고 유효하지 않으면 토큰 에러를 발생 시키고 진행을 중단한다.\n오류 처리 서버를 돌리다 보면 수많은 잘못된 요청들이 들어올 수가 있다. 웹 사이트 url이 잘못되었거나, 필수 파라미터가 없거나 잘못되었거나, 아님 내부 서버 오류도 발생할 수 있다. 이러한 오류들을 라우팅 함수들마다 처리하는 것보단, 한 곳으로 모아서 처리하는 것이 더 좋겠다는 생각을 했다. 그래서 Javascript의 Error Object를 이용하기로 했다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 export class WPAError extends Error { statusCode: number; responseMessage: string; constructor(message: string, statusCode: number) { super(message); this.statusCode = statusCode; this.responseMessage = message; } } export class MissingRequiredParametersError extends WPAError { missingParams: string[]; constructor(missingParams: string[]) { super(`Missing required parameters (${missingParams.join(', ')})`, 400); this.name = 'MissingRequiredParametersError'; Object.setPrototypeOf(this, MissingRequiredParametersError.prototype); this.missingParams = missingParams; } } 부모 클래스로 WPAError를 만들었다. 이 클래스는 오류가 발생했을 때 클라이언트에게 보여 줄 상태 코드와 응답 메시지를 가지고 있다. 그리고 자식 클래스들은 생성자에서 해당 오류의 상태 코드와 메시지 내용을 넣어 준다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 this.koaApp.use(async (ctx, next) =\u003e { try { await next(); } catch (err) { if(err instanceof WPAError) { ctx.status = err.statusCode; ctx.body = err.responseMessage; } else { ctx.status = 500; } ctx.app.emit(\"error\", err, ctx); } }); this.koaApp.on(\"error\", (err, ctx) =\u003e { Log.error(`APIServer: Error in ${ctx.request.method}:${ctx.request.url}\\n ${err.stack}`); }); 그리고 에러를 처리하는 미들웨어를 가장 위쪽에 등록을 한다. 그러면 라우팅하는 함수에서 위에서 정의한 Error들을 던지면 여기서 받게 된다. 받은 에러가 WPAError의 자식이면 해당하는 상태 코드와 메시지를 보내고, 아니면 그냥 Internal Server Error(500)을 보낸다. 이렇게 에러를 처리하는 부분을 한 곳으로 모아서 처리를 했다.\nPushServer 새로운 글이 올라왔을 때 알려주는 서버인데… 아직 구현을 하진 않았다.\nCore 서버의 중심 부분이며, WebSiteWatcher들을 관리한다. 또한 기능들간 연결 고리 역할을 한다.\n예를 들어 APIServer에서 새로운 웹 사이트를 등록하는 요청을 받았다고 하자. 그러면 먼저 APIServer에서 파라미터들을 정리해 WebSiteInfo 정보를 만들고 core.insertWebSite함수를 호출한다. 이 함수에서는 DB에 새로운 웹 사이트를 넣고, WebSiteWatcher를 새로 생성하고 활성화한다. 이 과정이 완료되면 함수가 반환되면서 APIServer로 돌아가게 되고 완료 응답을 보내게 된다.\n이렇게 모든 로직이 Core를 지나가게 만들어서 로직을 최대한 단순하게 만들려고 했다.\n구현(Frontend) 위에서 결정한 것처럼 프론트엔드는 quasar framework를 이용하기로 결정했다. 여기에 TypeScript를 적용 시키고 싶어서 찾아보니까 따로 extension이 있었다. 그래서 적용해보니까 js파일들이 ts로 바뀌긴 했는데 vue파일들은 그대로 바뀌는 게 없었다. 주로 vue파일을 수정할텐데 적용이 안 되어서 있으나 마나였다.\n그래서 따로 찾아보니까 vue-property-decorator라는 것을 찾았다. 이 라이브러리는 decorator를 이용해 좀 더 쉽고 깔끔하게 컴포넌트를 설정할 수가 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 export default { props: { propA: { type: Number }, propB: { default: 'default value' }, propC: { type: [String, Boolean] } } } 예를 들어 컴포넌트의 prop들을 설정하려면 위에처럼 각 prop들의 정보를 object로 넣어줘야 하는데, decorator를 이용하면\n1 2 3 4 5 6 7 8 import { Vue, Component, Prop } from 'vue-property-decorator' @Component export default class YourComponent extends Vue { @Prop(Number) readonly propA: number | undefined @Prop({ default: 'default value' }) readonly propB!: string @Prop([String, Boolean]) readonly propC: string | boolean | undefined } 이렇게 깔끔하게 쉽게 prop들을 정의할 수가 있다.\n다만 아직 정식 기능이 아닌 decorator를 이용하기 때문에 JavaScript는 babel을 이용해야 하고, TypeScript는 컴파일러 옵션에 experimentalDecorators를 true로 설정해줘야 한다.\n이외에는 그냥 Vue로 웹 페이지 개발을 했다. 확실히 UI 프레임워크를 쓰니까 쉽고 이쁘게 만들수가 있었다.\n배포 프론트엔드와 백엔드를 다른 프레임워크로 만든 경우 프론트엔드를 표시할 웹 서버와 백엔드 서버, 2개의 서버가 필요하다.\n백엔드 서버 먼저 백엔드 서버를 만들 때 멈추지 않고 자동으로 배포되는 서버를 구축하고 싶었다. 그래서 열심히 찾아보니까 Docker + CI(Jenkins, Travis CI…)를 이용하면 구축할 수가 있다고 한다. 간단히 설명하자면,\nGitHub에서 최신 commit이 올라옴 Travis CI에서 감지해서 해당 버전으로 docker image를 만듦 새로 만들어진 image를 docker container에 띄움 (이때 기존 서버는 돌아가고 있음) 새로운 서버가 성공적으로 띄워지면 기존 서버를 내림 의외로 생각보다 간단한데, 아직 Travis CI를 잘 쓰지 못하겠어서 자동 배포까지는 구현을 못했고, 간단한 스크립트로 수동 배포까지만 구현했다.\nDocker 이미지 생성 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #!/bin/bash DIR=\"$( cd \"$( dirname \"$0\" )\" \u0026\u0026 pwd )\" cd $DIR echo echo \"Getting wpa-server source from github...\" if [ -d \"src\" ]; then cd src git pull else git clone https://github.com/Cube219/WebPageAlerter.git src cd src fi VER=$(cat package.json \\ | grep version \\ | head -1 \\ | awk -F: '{ print $2 }' \\ | sed 's/[\",]//g' \\ | tr -d '[[:space:]]') echo echo \"Building docker images... (version: $VER)\" docker build -t cube219/wpa-server:latest -t cube219/wpa-server:v$VER . echo echo \"Successfully build docker images.\" 자동으로 GitHub에서 소스를 가져와서 이미지를 빌드하는 스크립트이다. 버전 정보는 package.json파일에서 가져온다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 FROM node:10.14.1-alpine AS installer WORKDIR /usr/src/WebPageAlerter/build COPY package*.json ./ RUN npm install --production RUN npm install -g --production typescript # ---------------------------- FROM installer AS builder WORKDIR /usr/src/WebPageAlerter/build COPY ./src src COPY tsconfig.json . RUN tsc # ---------------------------- FROM node:10.14.1-alpine WORKDIR /app/WebPageAlerter COPY --from=builder /usr/src/WebPageAlerter/build/dist dist COPY --from=builder /usr/src/WebPageAlerter/build/node_modules node_modules COPY package*.json ./ CMD [ \"node\", \"dist/main.js\" ] Dockerfile 내용이다. 간략하게 설명하면\npackage.json 파일을 가져와서 npm install을 해 필요한 패키지들을 가져온다. src파일을 가져와 TypeScript 컴파일을 한다. 컴파일 결과인 dist 폴더와 node_modules 폴더만 가져온다. Docker 이미지 띄우기 이미지를 만들었으니 이제 띄우기만 하면 된다. 이미지를 띄우는 것은 docker-compose를 이용했다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 version: '3' services: mainserver: image: \"cube219/wpa-server:latest\" container_name: wpa-server depends_on: - mongodb ports: - \"8000:8000\" volumes: - ./logs:/app/WebPageAlerter/logs - ./page_data:/app/WebPageAlerter/page_data environment: API_SERVER_PORT: 8000 API_SERVER_USE_HTTP2: 'false' API_SERVER_PASSWORD: $PASSWORD JWT_SIGNATURE_SECRET_KEY: $SIG_KEY API_SERVER_ENABLE_AUTH: 'true' DB_URL: mongodb DB_PORT: 27017 networks: - backend mongodb: image: \"mongo:latest\" container_name: wpa-db hostname: mongodb volumes: - ./db_data:/data/db networks: - backend networks: backend: driver: bridge 서버에 들어갈 매개변수들을 설정하고, 컨테이너가 재 시작해도 데이터가 안 날아가게 볼륨을 마운트하고, db와 연결하는 이 모든 과정들을 쉽게 할 수 있었다. 만약 이미지가 업데이트가 되었다면 그냥\n$ docker-compose -f docker-compose.yml up -d\n만 입력하면 알아서 최신 이미지로 업데이트를 할 수 있다.\n완전 자동화는 아니지만 어느 정도 자동화는 해둔 덕분에 서버 업데이트를\n수정 commit을 GitHub에 push 서버에 ssh로 접속해서 build.sh 실행 docker-compose -f docker-compose.yml up -d 입력 이렇게 쉽게 할 수 있다.\n프론트엔드 서버 프론트엔드는 Vue로 만들었기 때문에 빌드를 하면 static 파일들이 생성이 되고, 이것을 Nginx에다 올리면 프론트엔드 서버 구현 완료다.\n같은 물리적 서버에서 도메인으로 프론트 / 백엔드 구분하기 프론트 / 백엔드를 따로 구현했기 때문에 서버가 2개가 필요하다. 하지만 실제로는 서버를 1개만 가지고 있기 때문에 리버스 프록시를 구축했다.\n먼저 백엔드 서버 도메인인 wpa-server.cube219.me와 프론트엔드 서버 도메인인 wpa.cube219.me를 같은 프록시 서버 주소를 가리키게 설정을 한다. 그러면 프록시 서버에서는 들어온 요청이 백엔드 도메인인지, 프론트엔드 도메인인지 확인 후 알맞은 서버로 연결을 한다.\n이것도 Nginx로 구현이 가능하다.\nserver { listen 80; server_name wpa-server.cube219.me; return 301 https://wpa-server.cube219.me$request_uri; } server { listen 443 ssl http2; server_name wpa-server.cube219.me; autoindex off; ssl_certificate /etc/letsencrypt/live/cube219.me/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/cube219.me/privkey.pem; location / { proxy_pass http://localhost:8000; } } server { listen 80; server_name wpa.cube219.me; return 301 https://wpa.cube219.me$request_uri; } server { listen 443 ssl http2; server_name wpa.cube219.me; autoindex off; ssl_certificate /etc/letsencrypt/live/cube219.me/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/cube219.me/privkey.pem; location / { root /home/Cube219/wpa-client/dist; } } Nginx설정에서 server안에 server_name을 입력하면 해당 도메인으로 요청이 왔을 때 해당 서버로 연결해준다. 이것을 이용해 wpa-server.cube219.me인 경우에는 아까 Docker로 열어둔 백엔드 서버 8000포트로 넘겨주고, wpa.cube219.me인 경우 Vue로 빌드한 결과물들이 있는 폴더로 넘어가게 된다.\n구현 모습 맨 처음 로그인 화면이다. 여기서 올바른 비밀번호를 입력하면 토큰을 받고 메인 화면으로 이동한다.\n메인 화면이다. 미리 등록한 웹 사이트에 새로운 글이 올라오면 모아서 여기에 보여 준다. 3일 전에 올라온 글이면 오른쪽 위에 New 뱃지가 나온다. 이미 읽은 글은 카드 배경이 회색으로 변한다.\n카드에 있는 점 3개를 클릭하면 이 글을 따로 보관할 수가 있다. 이외에도 카드를 읽음/읽지 않음으로 표시하거나 지울 수도 있다.\n오른쪽 밑에 있는 +버튼을 누르면 새로운 페이지를 보관할 수 있는 창이 뜬다. URL과 카테고리를 선택하고 추가를 누르면 아래에 설명할 보관된 페이지에 해당 페이지가 보관된다.\n왼쪽 밑에 있는 보관된 페이지를 누르면 따로 보관한 페이지들을 볼 수가 있다.\n이외에도 웹 사이트 설정 / 기본 설정 페이지도 있어야 하지만 아직 미 구현이라 수동으로 서버에 요청을 보내 수정하고 있다.\n백엔드 소스코드와 프론트엔드 소스코드를 GitHub에 올리긴 했지만 아직 README등 정리가 안 되어있다. 차후 정리해서 작성할 예정이다.\n느낀 점 이 프로젝트는 잠깐 쉴 겸해서 만든 간단한 프로젝트였는데, 생각보다 간단하지 않았다. 한 1~2개월이면 만들 줄 알았는데 거의 5개월이나 걸렸다. 프로젝트를 진행하다 보니까 욕심이 나서 기능들을 추가하는 경우도 있었고, JWT, mongoose, 토큰 개념 등 여러 기술들을 배우느라 시간이 더 걸린 것 같다. 그래도 웹에 대해서 어느 정도 지식이 쌓이긴 했다.\n시간은 생각보다 오래 걸렸지만 프로젝트를 진행하면서 재미있었고 열심히 했다. 불편하고 귀찮은 일을 자동으로 해주는 서비스를 만들어서 동기부여가 잘 되었던 것 같다. 가끔씩 이런 소소한 프로젝트를 하는 것도 좋은 것 같다.\n","description":"","tags":[],"title":"웹사이트 새 글을 자동으로 확인해 알려주는 알리미 만들기","uri":"/posts/2019/making-a-alerter-for-new-posts/"},{"categories":["Programming","C++"],"content":"오늘 슬랙을 보다가 재미난 글이 올라왔다.\n1 2 3 4 5 6 int x = 5; while(x --\u003e 0) { std::cout \u003c\u003c x \u003c\u003c \" \"; } // 출력: 4, 3, 2, 1, 0 C++에 새로운 연산자가 추가되었다는 내용이였는데, while문에 --\u003e를 쓰면 x가 하나씩 줄면서 반복문을 돌게 된다는 것이다.\n처음 봤을 때는 재미있는 연산자가 추가되나보다 생각을 했다. 근데 글을 더 읽어보니 이게 이전 버전의 C++에서도 동작을 한다는 것이였고, 실제로 돌려보니 동작을 했다! 여기서 뭔가 이상하다고 생각을 해서 자세히 보니까 진실을 알게 되었다.\n1 while(x --\u003e 0) =\u003e while((x--) \u003e 0) 실제로는 x에 --연산자가 붙고, x--가 0보다 큰지 검사하는 구문이다. 이걸 띄어쓰기를 적절히 활용해서 마치 --\u003e라는 새로운 연산자가 있는것처럼 보이는 것이다.\n이 사실을 알았을 때, 어이가 없으면서 재미있었다. 이처럼 C++에서는 재미있는 상황이 많이 있는 것 같다.\nC++에서 볼 수 있는 또다른 재미있는 상황이 있다.\n1 d[i] == *(d + i) 배열에 있는 값에 접근을 할 때, 컴파일러는 위와 같이 처리를 한다. 여기서 +는 앞뒤를 서로 바꿔도 같은 값이기 때문에, 아래의 식들도 모두 같다.\n1 d[i] == *(d + i) == *(i + d) == i[d] 이를 응용하면 다음과 같은 끔찍한(!) 코드도 실행이 된다.\n1 2 3 4 5 d[1] = 2[d] = 1; for(int i = 3; i \u003c= 20; i++) { i[d] = d[i-1] + (i-2)[d]; } // d: 1 1 2 3 5 8 13 ... 어떻게 보면 언어의 결함이라고 볼 수 있을 것 같다. 저런건 컴파일러 단계에서 막을 수 있을 것 같은데 왜 막지 않았을까?\n","description":"","tags":[],"title":"C++의 새로운 연산자?","uri":"/posts/2019/new-operator-in-cpp/"},{"categories":["Blog"],"content":"이 블로그는 Hugo라는 정적 웹 페이지 생성기로 만들었는데, 정적 웹 페이지인 경우 서버에 있는 데이터를 실시간으로 수정하지 않기 때문에 댓글 기능을 구현하기가 힘들다. 그래서 이러한 댓글 기능을 추가하는 여러 서비스들이 있다. 이 테마에서는 disqus하고 staticman을 지원해서 한 번 적용시켜봤는데, 둘 다 만족스럽지가 않았다.\nDisqus의 경우 장점 구현하기가 쉽다. (Hugo의 경우 기본적으로 지원) 단점 disqus 계정에 가입을 해야 댓글을 달 수 있다. Staticman의 경우 장점 댓글의 내용이 자동으로 서버에 저장된다. 따로 계정을 만들 필요가 없다. 단점 서버에 저장하고 배포하는 과정이 필요해서 댓글을 다는데 시간이 걸린다. GitHub Page만 지원한다. 이러한 단점들이 있어서 다른 것이 있나 찾아보다가, utterances를 발견하게 된다.\nUtterances 이 서비스는 GitHub의 issue를 이용해 댓글을 달고 표시를 한다. Issue를 각 게시글과 연결하고, 댓글을 달면 그 Issue에 글을 쓰는 방식으로 동작한다. 단점이라면 GitHub계정이 있어야 한다는 점이지만, 이 블로그는 개발자 블로그라서 괜찮을 것 같았다.(다들 GitHub 계정이 있지 않을까?)\nUtterances 적용 먼저 Issue들을 생성할 GitHub 저장소를 준비한다. 이때 저장소는 public으로 만들어야 한다. 새로 댓글 전용 저장소를 만들어도 되지만, 필자는 기존의 GitHub Blog를 이용했다.\n그리고 utterances 홈페이지로 가서 설정을 하면 된다.\nRepository에서는 아까 준비한 저장소 이름을 넣으면 된다.\n블로그 글과 Issue를 어떻게 mapping할 것인지 정하는 설정이다. 보통은 pathname이나 title을 써도 잘 작동을 하나, 필자의 블로그는 그럴수가 없었다.\n필자의 블로그의 처음 화면은 가장 최근에 쓴 글을 띄우게 되어있다. 그래서 mapping을 pathname이나 title로 하게 될 경우, 처음 화면에서 댓글을 달면 기존의 issue가 아닌 새로운 issue에 써지게 된다.\n처음 화면의 pathname은 /이기 때문에 해당 글의 제목이 아닌 index로 issue가 생성되어 버리고, 연결도 엉뚱하게 된다.\n이러한 경우 때문에 수동으로 mapping을 해야 했다. 다행히 Hugo에서 .Title을 하면 해당 글의 제목을 알 수가 있어서 이것을 이용해 구현했다.\n1 2 3 4 5 6 7 \u003cscript src=\"https://utteranc.es/client.js\" repo=\"Cube219/Cube219.github.io\" issue-term=\"Comments: {{ .Title }}\" theme=\"github-light\" crossorigin=\"anonymous\" async\u003e \u003c/script\u003e 이외에 다른 설정들을 하고 나면 위와 같은 html코드가 보일 것이다. 이것을 복사해서 사이트에 붙여넣으면 된다. 필자의 경우에는 기존 테마에 있던 comments.html 파일에 넣었다.\nIssue mapping에서 Specific issue number나 Issue title contains specific term을 선택할 경우 issue-term이 **[ENTER TERM HERE]**나 **[ENTER ISSUE NUMBER HERE]**라고 나올텐데, 이는 수동으로 mapping을 해야 하는 경우이므로 사용자가 저 위치에다가 페이지마다 알맞은 값을 넣어야 한다.\n적용 후 이 글에 댓글을 달아보았다. 댓글을 달면 자동으로 GitHub issue를 생성해서 댓글을 다는 것을 볼 수 있다.\n","description":"","tags":[],"title":"utterances로 블로그 댓글 적용하기","uri":"/posts/2019/apply-blog-comments-with-utterances/"},{"categories":["Programming","EASTL"],"content":"최근 EASTL에 있는 string을 쓰면서 내부에 구현된 최적화 방법을 발견했는데, 이게 상당히 흥미로웠다.\nSSO(short string optimization) string은 보통 문자열 데이터를 담기 위해 동적 할당을 한다. 그래서 여러 string들을 합치고 빼다 보면 heap 메모리 할당/해제가 빈번하게 발생한다.\n이러한 문제를 줄이기 위해, 짧은 문자열인 경우에는 동적 할당 대신에 동적 할당을 하는데 필요한 공간에다가 문자열을 넣어서 할당을 피하는 구조로 되어있다.\n1 2 3 4 5 6 7 8 9 10 struct Layout { union { HeapLayout heap; SSOLayout sso; RawLayout raw; }; ... 이렇게 Heap을 쓰는 경우에 사용하는 HeapLayout, SSO를 쓰는 경우에 사용하는 SSOLayout, 그리고 그냥 메모리 상태를 보여주는 RawLayout 이 3가지가 union으로 묶여 있다.\n1 2 3 4 5 6 struct HeapLayout { value_type* mpBegin; size_type mnSize; size_type mnCapacity; }; Heap을 이용할 경우에는 할당받은 포인터(mpBegin), 크기(mnSize) 그리고 할당 크기(mnCapacity) 정보가 필요하다.\n이럴 경우, 64비트 아키텍처 기준으로는 총 8+8+8=24byte가 사용된다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 template \u003ctypename CharT, size_t = sizeof(CharT)\u003e struct SSOPadding { char padding[sizeof(CharT) - sizeof(char)]; }; template \u003ctypename CharT\u003e struct SSOPadding\u003cCharT, 1\u003e { // template specialization to remove the padding structure to avoid warnings on zero length arrays // also, this allows us to take advantage of the empty-base-class optimization. }; // The view of memory when the string data is able to store the string data locally (without a heap allocation). struct SSOLayout { enum : size_type { SSO_CAPACITY = (sizeof(HeapLayout) - sizeof(char)) / sizeof(value_type) }; // mnSize must correspond to the last byte of HeapLayout.mnCapacity, so we don't want the compiler to insert // padding after mnSize if sizeof(value_type) != 1; Also ensures both layouts are the same size. struct SSOSize : SSOPadding\u003cvalue_type\u003e { char mnRemainingSize; }; value_type mData[SSO_CAPACITY]; // Local buffer for string data. SSOSize mRemainingSizeField; }; SSO에서는 이 24byte를 활용해서 문자열을 집어넣는다. 남은 문자를 저장하기 위해 최소 1byte를 남겨두고 나머지를 문자열을 담을 공간으로 활용한다.\n여기서는 남은 문자열 크기(mnRemainingSize)를 padding까지 해서 무조건 HeapLayout의 마지막 byte에 두는데, 이는 지금 Heap인지 SSO인지 확인하는데 이 byte를 쓰기 때문이다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #ifdef EA_SYSTEM_BIG_ENDIAN // Big Endian use LSB, unless we want to reorder struct layouts on endianness, Bit is set when we are in Heap static constexpr size_type kHeapMask = 0x1; static constexpr size_type kSSOMask = 0x1; #else // Little Endian use MSB static constexpr size_type kHeapMask = ~(size_type(~size_type(0)) \u003e\u003e 1); static constexpr size_type kSSOMask = 0x80; #endif ... inline bool IsHeap() const EA_NOEXCEPT { return !!(sso.mRemainingSizeField.mnRemainingSize \u0026 kSSOMask); } ... // Largest value for SSO.mnSize == 23, which has two LSB bits set, but on big-endian (BE) // use least significant bit (LSB) to denote heap so shift. inline size_type GetSSOSize() const EA_NOEXCEPT { #ifdef EA_SYSTEM_BIG_ENDIAN return SSOLayout::SSO_CAPACITY - (sso.mRemainingSizeField.mnRemainingSize \u003e\u003e 2); #else return (SSOLayout::SSO_CAPACITY - sso.mRemainingSizeField.mnRemainingSize); #endif } inline void SetSSOSize(size_type size) EA_NOEXCEPT { #ifdef EA_SYSTEM_BIG_ENDIAN sso.mRemainingSizeField.mnRemainingSize = (char)((SSOLayout::SSO_CAPACITY - size) \u003c\u003c 2); #else sso.mRemainingSizeField.mnRemainingSize = (char)(SSOLayout::SSO_CAPACITY - size); #endif } ... inline void SetHeapCapacity(size_type cap) EA_NOEXCEPT { #ifdef EA_SYSTEM_BIG_ENDIAN heap.mnCapacity = (cap \u003c\u003c 1) | kHeapMask; #else heap.mnCapacity = (cap | kHeapMask); #endif } inline size_type GetHeapCapacity() const EA_NOEXCEPT { #ifdef EA_SYSTEM_BIG_ENDIAN return (heap.mnCapacity \u003e\u003e 1); #else return (heap.mnCapacity \u0026 ~kHeapMask); #endif } 지금 상태가 Heap인지 SSO인지는 특이하게 판단한다. Layout의 마지막 byte에 masking bit를 넣어서 판단하는데, little endian이랑 big endian이랑 넣는 위치가 다르다.\nlittle endian인 경우 해당 byte의 MSB에다가 넣는다. 이경우 MSB가 1이면, SSO 입장에서는 mnRemainingSize가 음수이기 때문에 이런 상황이 나올 수가 없고, Heap 입장에서는 저 bit가 mnCapacity에선 매우 큰 값을 나타내기 때문에 masking에 써도 괜찮다.\nbig endian인 경우 해당 byte의 LSB에다가 넣고, 실제 값은 왼쪽으로 shifting해서 넣는다. 여기서 SSO의 mnRemainingSize는 왼쪽으로 2번 shifting하는데 왜 그러는지는 모르겠다. 1번만 해도 될 것 같은데?\n굳이 bool변수를 안 넣고 이렇게 masking bit를 넣는 것은 공간 낭비를 최소화하려고 그런게 아닐까 생각한다.\n1 2 3 4 5 6 7 8 9 10 11 struct Layout { ... inline value_type* BeginPtr() EA_NOEXCEPT { return IsHeap() ? HeapBeginPtr() : SSOBeginPtr(); } ... inline value_type* EndPtr() EA_NOEXCEPT { return IsHeap() ? HeapEndPtr() : SSOEndPtr(); } ... 해당 주소에 접근 할 때는 현재 상태를 확인하고 이에 맞는 포인터를 반환한다. 여기서 if 분기문을 거치기 때문에 branch prediction이 실패할 경우 약간의 성능 오버헤드가 발생하게 된다.\n결론 짧은 문자열들이 여러 개가 있을 경우 위의 최적화가 유용하지만, 주소에 접근을 할 때 확인을 하는 작업이 추가되기 때문에 그에 따른 성능 오버헤드가 생길 수도 있다. 그래도 할당/해제하는 것보다는 빠르지 않을까?\n","description":"","tags":[],"title":"EASTL SSO(short string optimization)","uri":"/posts/2019/eastl-sso/"},{"categories":["Programming","C++"],"content":"개인적으로 만들고 있는 게임 엔진에서 문자열 formatting은 {fmt} 라이브러리를 사용하고 있다.\n이게 예전 버전에서는 UTF-16 / 32(char16_t, char32_t)가 지원이 안 되어서 소스코드를 수정해서 쓰고 있었지만, C-style 문자열(const char16_t*, …)을 parameter로 넘기면 컴파일 오류가 발생한다.\n고치려고 했지만 너무 복잡할 것 같아서 그냥 쓰다가, 최근 버전을 보니까 자동으로 UTF-16 / 32도 지원하는 것 같아서 라이브러리를 업데이트 했다.\n업데이트를 하고 Custom formatting도 설정하고 빌드를 하는데… 컴파일 오류가 난다.\n찾아보니까 그냥 character랑 wide character랑 섞어서 쓰는 것을 금지하고 있는데, 이게 char16_t와 char32_t도 적용이 되는 모양이다.\n그래서 소스코드 수정할까 생각도 해봤지만, 그냥 wrapper 함수를 만들어서 다른 character이면 변환해서 호출해야겠다고 생각했다.\n1 2 3 4 5 template \u003ctypename S, typename ...Args\u003e inline eastl::basic_string\u003ctypename fmt::v5::char_t\u003cS\u003e::type\u003e Format(const S\u0026 format_str, const Args\u0026 ...args) { return fmt::format(format_str, convert_string(args)...); } fmt::format함수를 참조해서 wrapper를 만들었다.\n각 parameter마다 convert_string함수를 거쳐서 특정 type에서는 변환해 다른 타입으로 반환하게 하면 된다. 이제 구현만 하면 되는데… 여기서 문제가 발생한다.\n해당 type이 문자열인가? 문자열인 경우, formatting 문자열이랑 같은 type인가? 위의 상황에는 다른 type을, 아닐 경우 기존의 type을 반환해야 하는데 이게 가능한가? 여러가지 방법들을 찾아보다가, std::enable_if를 이용하면 가능할 것 같았고, 실제로 구현을 했다.\nenable_if에 관한 내용은 다음을 참고하면 될 것 같다.\nconvert_string 함수 구현 convert_string함수는 특정 type을 parameter로 받으면 다른 type으로 변환해 반환하고, 아니면 그대로 값을 반환하는 함수로 만들어야 한다. 위와 같은 상황에서는 3가지 경우가 있다.\n1. String이 아닌 경우 1 2 3 4 5 6 7 // Not a string template \u003ctypename S, typename T\u003e inline typename std::enable_if\u003c!fmt::v5::internal::is_string\u003cT\u003e::value, const T\u0026\u003e::type convert_string(const T\u0026 value) { return value; } is_string\u003cT\u003e는 해당 타입이 string인 경우 true가 되는 type traits이다. 내부적으로는 string_view를 만들 수 있는지로 확인한다.\n간단하게, string이 아닌 경우 parameter의 type으로 그냥 반환한다.\n2. String이나, formatting string이랑 같은 type인 경우 1 2 3 4 5 6 7 8 9 // Same string type template \u003ctypename S, typename T\u003e inline typename std::enable_if\u003c fmt::v5::internal::is_string\u003cT\u003e::value \u0026\u0026 IS_SAME_STR_TYPE(S, T), const T\u0026\u003e::type convert_string(const T\u0026 value) { return value; } 같은 type인지는 IS_SAME_STR_TYPE 매크로에서 확인한다. 구현 내용은 생략한다.\nIS_SAME_STR_TYPE 구현은 여기에서 볼 수 있다.\n역시 이 경우에도 parameter의 type으로 그냥 반환한다.\n3. String이고, formatting string이랑 다른 type인 경우 1 2 3 4 5 6 7 8 9 10 // Different string type template \u003ctypename S, typename T\u003e inline typename std::enable_if\u003c fmt::v5::internal::is_string\u003cT\u003e::value\u0026\u0026 !IS_SAME_STR_TYPE(S, T), fmt::v5::basic_string_view\u003cS\u003e\u003e::type convert_string(const T\u0026 value) { auto\u0026 tempStr = GetTempString\u003cS\u003e(value); return tempStr; } 이 경우에는, enable_if에서 2번때 template parameter가 다른 것을 볼 수가 있다. const T\u0026 대신에 basic_string_view\u003cS\u003e를 반환하게 만들어서 다른 type을 반환하게 만들었고, 내부에서는 변환한 임시 string을 반환한다.\n결론 위의 경우처럼 variadic template에서 일부 parameter type을 바꾸고 싶은 경우, 특정 상황에서 type을 바꾸는 converter 함수를 만들고 각 parameter마다 해당 함수를 호출하게 만들면 된다.\nconverter 함수는 std::enable_if를 활용해 특정 상황에서 다른 type을 반환하게 만들면 된다.\n","description":"","tags":[],"title":"Variadic Template에서 일부 Parameter Type을 바꾸기","uri":"/posts/2019/change-some-parameter-types-in-variadic-template/"}]
